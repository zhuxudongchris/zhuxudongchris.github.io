{"meta":{"title":"chris的blog","subtitle":"","description":"","author":"chris","url":"http://chrisxd.gitee.io/blog","root":"//blog/"},"pages":[],"posts":[{"title":"leetcode题解","slug":"leetcode题解","date":"2020-06-28T07:57:41.000Z","updated":"2020-06-28T08:12:24.562Z","comments":true,"path":"2020/06/28/leetcode题解/","link":"","permalink":"http://chrisxd.gitee.io/blog/2020/06/28/leetcode%E9%A2%98%E8%A7%A3/","excerpt":"","text":"java数据类型12float f1 = 1.65; //会报错，1.65默认为double类型，不能直接赋值给floatfloat f1 = 1.65F;//正确 位操作符 字符串连接符 ==注意==：char类型要看成两个字节的整数类型","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://chrisxd.gitee.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"leetcode题解","slug":"django模型","date":"2020-06-28T07:57:41.000Z","updated":"2020-06-28T11:15:47.304Z","comments":true,"path":"2020/06/28/django模型/","link":"","permalink":"http://chrisxd.gitee.io/blog/2020/06/28/django%E6%A8%A1%E5%9E%8B/","excerpt":"django模型","text":"django模型 django配置MYSQL数据库12345678910DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': 'blog', 'HOST': '127.0.0.1', 'USER': 'root', 'PASSWORD': 'root', 'PORT': '3306' &#125;&#125; 每一个模型都是继承自django.db.models.Model，模型的每一个属性相当于数据库的一个字段，每一个模型的映射一张数据库表。 常用字段 filed 类型 说明 AutoField 一个自动增长的整形类型的字段，通常你不需要自己添加，如果在你的模型中没有定义主键，Django会自动为你添加一个名为id的从1开始自增长的主键 BooleanField 布尔值类型，在数据库中表示为tinyint类型。默认值为null，如果要接收null值，需要使用NullBooleanField字段。在HTML中展示为checkbox CharField 在数据库中为varchar类型，必须指定max_length属性，在HTML中展示为 text input TextField 用来保存大量文本内容，不限长度，在HTML中变现为 textarea IntegerField 整数类型，取值范围-2147483648到2147483647（-2的31次方-2的31次方-1）。在HTML中表现为number Input标签。 EmailField 类似于charfield，在数据库底层也是一个vechar类型，默认最大长度为254个字符。但是虽然其为email类型，在保存到数据库中并不会做验证，只有用ModelForm进行表单验证的时候才起作用。 DateField 日期类型。在Python中是datetime.date类型，可以记录年月日。在映射到数据库中也是date类型。使用这个Field可以传递以下几个参数： 1. auto_now:在每次这个数据保存的时候，都使用当前的时间。比如作为一个记录修改日期的字段，可以将这个属性 设置为True。 2.auto_now_add：在每次数据第一次被添加进去的时候，都使用当前的时间。比如作为一个记录第一次入库的字段，可以将这个属性设置为True。 DateTimeField 日期时间类型。 在Python中是datetime.datetime类型，可以记录年月日时分秒，参数同上 TimeField 时间类型。在Python中是datetime.time类型,也有auto_now和auto_now_add两个参数。 DecimalField models.DecimalField(max_digits=None, decimal_places=None[, **options])使用 Decimal 实例表示固定精度的十进制数的字段。它有两个必须的参数：max_digits：数字允许的最大位数decimal_places：小数的最大位数例如，要存储的数字最大长度为3位，而带有两个小数位，可以使用：models.DecimalField( max_digits=3, decimal_places=2,...) ==注意：==在mysql 5.0以上的版本时关于字符长度中文字符和英文字符一样都是字面大小，不需要转化。 ==补充：关于aware时间和navie时间== 什么是navie时间？什么是aware时间？ navie时间：朴素的时间，不知道自己的时区 aware时间：清醒的时间，知道自己的时区 pytz库： 一个关于处理时区的库 12&gt;import pytz&gt;utc_timezone = pytz.timezone('UTC')#定义一个UTC的时区时间 astimezone方法： 将一个时区的时间转化为另外一个时区的时间。这个方法之内被aware类型的时间调用 不能被navie类型的时间调用 1234567&gt;import pytz&gt;from datetime import datetime #python中处理时间的包&gt;now = datetime.now()#这是一个navie类型的时间&gt;utc_timezone = pytz.timezone('UTC')#定义一个UTC的时区时间&gt;utc_now = now .astimezone(utc_timezone)#将当前时间转换化为UTC时区的时间&gt;&gt;ValueError:astimezone()cannot be applied to a native time&gt;#抛出异常 replace方法： 用来改变时间对象的一个属性 123&gt;now = now.replace(tzinfo=pytz.timezone('Asia/Shanghai'))&gt;utc_now = now.astimezone(utc_timezone)&gt;#这是就可以正确转换 django.utils.timezone.now方法： 会根据settings.py中是否设置类USE_TZ=true获取当前的时间。如果设置了，那么会获取一个navie类型的UTC时间。如果没有设置，那么会获取一个navie类型的时间 django.utils.timezone.localtime方法： 会根据setting.py中的TIME_ZONE来将一个aware类型的时间转化为TIME_ZONE中指定的时区的时间 对于在数据库中保存时间的时候就需要和本地时间一致的问题，除了将USE_TZ=false和手动添加8小时意外还没发现太好的办法 字段常用属性null默认false，当设置为true时,该字段为空时django会在数据中将该字段设置为null 避免在基于字符串的字段中使用，对于无数据django的管理是使用空字符串而不是null blank默认flase，设置为true时该字段允许为空 ==注意==：和null不同，null是数据库相关的，blank是验证相关的，如果blank=true，表单验证将会允许输入空值 db_column设置这个字段在中的名字，如果没有设置将默认采用字段名字 choices在HTMl中渲染为一个select box，需要先提供一个二维的二元元组，第一个元素表示存在数据库内真实的值，第二个表示页面上显示的具体内容。在浏览器页面上将显示第二个元素的值。例如： 1234567YEAR_IN_SCHOOL_CHOICES = ( ('FR', 'Freshman'), ('SO', 'Sophomore'), ('JR', 'Junior'), ('SR', 'Senior'), ('GR', 'Graduate'), ) 一般来说，最好将选项定义在类里，并取一个直观的名字，如下所示： 123456789101112131415161718192021from django.db import modelsclass Student(models.Model): FRESHMAN = 'FR' SOPHOMORE = 'SO' JUNIOR = 'JR' SENIOR = 'SR' YEAR_IN_SCHOOL_CHOICES = ( (FRESHMAN, 'Freshman'), (SOPHOMORE, 'Sophomore'), (JUNIOR, 'Junior'), (SENIOR, 'Senior'), ) year_in_school = models.CharField( max_length=2, choices=YEAR_IN_SCHOOL_CHOICES, default=FRESHMAN, ) def is_upperclass(self): return self.year_in_school in (self.JUNIOR, self.SENIOR) 要获取一个choices的第二元素的值，可以使用get_FOO_display()方法，其中的FOO用字段名代替。对于下面的例子： 123456789101112131415161718from django.db import modelsclass Person(models.Model): SHIRT_SIZES = ( ('S', 'Small'), ('M', 'Medium'), ('L', 'Large'), ) name = models.CharField(max_length=60) shirt_size = models.CharField(max_length=1, choices=SHIRT_SIZES)#使用方法：&gt;&gt;&gt; p = Person(name=\"Fred Flintstone\", shirt_size=\"L\")&gt;&gt;&gt; p.save()&gt;&gt;&gt; p.shirt_size'L'&gt;&gt;&gt; p.get_shirt_size_display()'Large' default字段的默认值，可以是值或者是一个可调用对象。如果是可调用对象，那么每次创建新对象时都会调用。 error_messages用于自定义错误信息。参数接收字典类型的值。字典的键可以是null、 blank、 invalid、 invalid_choice、 unique和unique_for_date其中的一个。 help_text渲染为HTML时额外显示在表单组件上的帮助文档 primary_key主键。 primary_key=True隐含null=False和unique=True的意思。一个模型中只能有一个主键字段！ unique设为True时，在整个表内该字段的数据不可重复，否则会报错。 模型元数据Meta在模型类中，可以指定元数据类Meta来配置模型的基本信息 12345678from django.db import modelsclass Ox(models.Model): horn_length = models.IntegerField() class Meta: # 注意，是模型的子类，要缩进！ ordering = [\"horn_length\"] verbose_name_plural = \"oxen\" db_table指定在数据库中，当前模型生成的数据表的表名。比如： 1db_table = 'my_freinds' verbose_name最常用的元数据之一！用于设置模型对象的直观、人类可读的名称。可以用中文。例如： 12verbose_name &#x3D; &quot;story&quot;verbose_name &#x3D; &quot;披萨&quot; 如果你不指定它，那么Django会使用小写的模型名作为默认值。 verbose_name_pluralverbose_name的复数，默认是在后面加个s ordering设置在提取数据的排序方式。后面章节会讲到如何查找数据。比如我想在查找数据的时候根据添加的时间排序 123ordering = ['pub_date'] # 表示按'pub_date'字段进行升序排列ordering = ['-pub_date'] # 表示按'pub_date'字段进行降序排列ordering = ['-pub_date', 'author'] # 表示先按'pub_date'字段进行降序排列，再按`author`字段进行升序排列。 default_related_name外键和表关系外键类定义为class ForeignKey(to,on_delete,**options)。第一个参数是引用的是哪个模型，第二个参数是在使用外键引用的模型数据被删除了，这个字段该如何处理，比如有CASCADE、SET_NULL等。这里以一个实际案例来说明。比如有一个User和一个Article两个模型。一个User可以发表多篇文章，一个Article只能有一个Author，并且通过外键进行引用。那么相关的示例代码如下： 12345678910class User(models.Model): username = models.CharField(max_length=20) password = models.CharField(max_length=100)class Article(models.Model): title = models.CharField(max_length=100) content = models.TextField() author = models.ForeignKey(\"User\",on_delete=models.CASCADE) 以上使用ForeignKey来定义模型之间的关系。即在article的实例中可以通过author属性来操作对应的User模型。这样使用起来非常的方便。示例代码如下： 123456789article = Article(title='abc',content='123')author = User(username='张三',password='111111')author.save()#在指定外键之前，应当先将引用的外键数据保存在数据库中article.author = authorarticle.save()# 修改article.author上的值article.author.username = '李四'article.save() 为什么使用了ForeignKey后，就能通过author访问到对应的user对象呢。因此在底层，Django为Article表添加了一个属性名_id的字段（比如author的字段名称是author_id），这个字段是一个外键，记录着对应的作者的主键。以后通过article.author访问的时候，实际上是先通过author_id找到对应的数据，然后再提取User表中的这条数据，形成一个模型。 如果想要引用另外一个app的模型，那么应该在传递to参数的时候，使用app.model_name进行指定。以上例为例，如果User和Article不是在同一个app中，那么在引用的时候的示例代码如下： 1234567891011# User模型在user这个app中class User(models.Model): username = models.CharField(max_length=20) password = models.CharField(max_length=100)# Article模型在article这个app中class Article(models.Model): title = models.CharField(max_length=100) content = models.TextField() author = models.ForeignKey(\"user.User\",on_delete=models.CASCADE) 如果模型的外键引用的是本身自己这个模型，那么to参数可以为&#39;self&#39;，或者是这个模型的名字。在论坛开发中，一般评论都可以进行二级评论，即可以针对另外一个评论进行评论，那么在定义模型的时候就需要使用外键来引用自身。示例代码如下： 12345class Comment(models.Model): content = models.TextField() origin_comment = models.ForeignKey('self',on_delete=models.CASCADE,null=True) # 或者 # origin_comment = models.ForeignKey('Comment',on_delete=models.CASCADE,null=True) 外键删除操作：如果一个模型使用了外键。那么在对方那个模型被删掉后，该进行什么样的操作。可以通过on_delete来指定。可以指定的类型如下： CASCADE：级联操作。如果外键对应的那条数据被删除了，那么这条数据也会被删除。 PROTECT：受保护。即只要这条数据引用了外键的那条数据，那么就不能删除外键的那条数据。 SET_NULL：设置为空。如果外键的那条数据被删除了，那么在本条数据上就将这个字段设置为空。如果设置这个选项，前提是要指定这个字段可以为空。 SET_DEFAULT：设置默认值。如果外键的那条数据被删除了，那么本条数据上就将这个字段设置为默认值。如果设置这个选项，前提是要指定这个字段一个默认值。 SET()：如果外键的那条数据被删除了。那么将会获取SET函数中的值来作为这个外键的值。SET函数可以接收一个可以调用的对象（比如函数或者方法），如果是可以调用的对象，那么会将这个对象调用后的结果作为值返回回去。 DO_NOTHING：不采取任何行为。一切全看数据库级别的约束。 以上这些选项只是Django级别的，数据库级别按照数据库设置来 mysql数据库删除时有四种可选项： RESTRICT(默认值,类似django的PROTECT), NO ACTION(类似RESTRICT) CASCADE(同django) SET NULL(同django) 表关系表之间的关系都是通过外键来进行关联的。而表之间的关系，无非就是三种关系：一对一、一对多（多对一）、多对多等。 一对多或多对一1class ForeignKey(to, on_delete, **options)[source] 应用场景：比如文章和作者之间的关系。一个文章只能由一个作者编写，但是一个作者可以写多篇文章。文章和作者之间的关系就是典型的多对一的关系。 实现方式：一对多或者多对一，都是通过ForeignKey来实现的。还是以文章和作者的案例进行讲解。 12345678class User(models.Model): username = models.CharField(max_length=20) password = models.CharField(max_length=100) class Article(models.Model): title = models.CharField(max_length=100) content = models.TextField() author = models.ForeignKey(\"User\",on_delete=models.CASCADE) 那么以后在给Article对象指定author，就可以使用以下代码来完成： 123456article = Article(title='abc',content='123')author = User(username='zhiliao',password='111111')# 要先保存到数据库中author.save()article.author = authorarticle.save() 并且如果要实现用户对文章的反向引用可以使用artivle_set来实现，示例代码如下： 12345user = User.objects.first()# 获取第一个用户写的所有文章articles = user.article_set.all()for article in articles: print(article) article_set为django默认为被外键引用的对象添加的Queryset类型的属性可以通过Foreignkey的releted_name重新指定该属性的名字(article_set-&gt;artivles) 一对一1class OneToOneField(to, on_delete, parent_link=False, **options)[source] 在Django中一对一是通过models.OnetToOneField来实现的。这个OneToOneField其实本质上就是一个外键，只不过这个外键有一个唯一约束（unique key），来实现一对一。 以后如果想要反向引用，那么是通过引用的模型的名字转换为小写的形式进行访问。比如以下模型： 12345678910class FrontUser(models.Model): username = models.CharField(max_length=200)class UserExtension(models.Model): school = models.CharField(max_length=100) user = models.OneToOneField(\"FrontUser\",on_delete=models.CASCADE)# 通过userextension来访问UserExtension对象user = FrontUser.objects.first()print(user.userextension) UserExtension的对象，可以通过user来访问到对应的user对象。并且FrontUser对象可以使用userextension来访问对应的UserExtension对象。如果不想使用Django默认的引用属性名字。那么可以在OneToOneField中添加一个related_name参数。示例代码如下： 12345678910class FrontUser(models.Model): username = models.CharField(max_length=200)class UserExtension(models.Model): school = models.CharField(max_length=100) user = models.OneToOneField(\"FrontUser\",on_delete=models.CASCADE,related_name='extension')# 通过extension来访问到UserExtension对象user = FrontUser.objects.first()print(user.extension) 那么以后就FrontUser的对象就可以通过extension属性来访问到对应的UserExtension对象。 多对多1class ManyToManyField(to, **options)[source] 应用场景：比如文章和标签的关系。一篇文章可以有多个标签，一个标签可以被多个文章所引用。因此标签和文章的关系是典型的多对多的关系。 实现方式：Django为这种多对多的实现提供了专门的Field。叫做ManyToManyField。还是拿文章和标签为例进行讲解。示例代码如下： 1234567class Article(models.Model): title = models.CharField(max_length=100) content = models.TextField() tags = models.ManyToManyField(\"Tag\",related_name=\"articles\")class Tag(models.Model): name = models.CharField(max_length=50) 在数据库层面，实际上Django是为这种多对多的关系建立了一个中间表。这个中间表分别定义了两个外键，引用到article和tag两张表的主键。中间表的表名默认为：app名_model名_模型多对多字段名 自定义中间表 一般情况，普通的多对多已经够用，无需自己创建第三张关系表。但是某些情况可能更复杂一点，比如如果你想保存某个人加入某个分组的时间呢？想保存进组的原因呢？ Django提供了一个through参数，用于指定中间模型，你可以将类似进组时间，邀请原因等其他字段放在这个中间模型内。例子如下： 12345678910111213141516171819from django.db import modelsclass Person(models.Model): name = models.CharField(max_length=128) def __str__(self): return self.nameclass Group(models.Model): name = models.CharField(max_length=128) members = models.ManyToManyField(Person, through='Membership', through_fields=('group','person')) def __str__(self): return self.nameclass Membership(models.Model): person = models.ForeignKey(Person, on_delete=models.CASCADE) group = models.ForeignKey(Group, on_delete=models.CASCADE) date_joined = models.DateField() # 进组时间 invite_reason = models.CharField(max_length=64) # 邀请原因 在中间表中，我们至少要编写两个外键字段，分别指向关联的两个模型。在本例中就是‘Person’和‘group’。 这里，我们额外增加了‘date_joined’字段，用于保存人员进组的时间，‘invite_reason’字段用于保存邀请进组的原因。 through_fields参数接收一个二元元组(‘field1’, ‘field2’)，field1是指向定义有多对多关系的模型的外键字段的名称，这里是Membership中的‘group’字段（注意大小写），另外一个则是指向目标模型的外键字段的名称，这里是Membership中的‘person’ 。 ==总结==：在对模型进行反向引用的时候，外键默认使用字段名+_set，一对一可直接使用字段名，多对多默认使用字段名+_set。默认名字可以通过字段属性releted_name重新指定。 模型对象操作创建对象123from blog.models import Blogb = Blog(name='Beatles Blog', tagline='All the latest Beatles news.')b.save() 当你创建了一个对象以后，如果你没有显示的条用save方法，Django并不会把它插入到数据库中，上面的操作等价于： 1b = Blog.objects.create(name='Beatles Blog', tagline='All the latest Beatles news.') 保存对象save方法还可以用来将对数据的修改保存到数据库中 12b.name='new name'b.save()#修改之后一定要保存 添加修改外键可直接使用上面的保存属性的方法。而对于通过反向引用来添加需使用add方法： 123456article1=Article(title='abc')article2=Article(titile='def')#在add之前一定要先保存数据article1.save()article2.save()category.article_set.add(article1,article2) 对于多对多的数据添加，两边对需要使用add方法 QuerySet APIall：获取这个模型的QuerySet对象，返回某张表的所有记录 filter(**Kwargs)：返回一个根据指定参数查询出来的QuerySet exclude(**kwargs)：返回除了根据指定参数查询出来结果的QuerySet annotate：给QuerySet中的每个对象都添加一个使用查询表达式（聚合函数、F表达式、Q表达式、Func表达式等）的新字段。示例代码如下： 1articles = Article.objects.annotate(author_name=F(\"author__name\")) aggregate：使用聚合函数。 order_by：指定将查询的结果根据某个字段进行排序。如果要倒叙排序，那么可以在这个字段的前面加一个负号。示例代码如下： 12345678# 根据创建的时间正序排序 articles = Article.objects.order_by(\"create_time\") # 根据创建的时间倒序排序 articles = Article.objects.order_by(\"-create_time\") # 根据作者的名字进行排序 articles = Article.objects.order_by(\"author__name\") # 首先根据创建的时间进行排序，如果时间相同，则根据作者的名字进行排序 articles = Article.objects.order_by(\"create_time\",'author__name') 一定要注意的一点是，多个order_by，会把前面排序的规则给打乱，而使用后面的排序方式。比如以下代码： 1articles = Article.objects.order_by(\"create_time\").order_by(\"author__name\") 他会根据作者的名字进行排序，而不是使用文章的创建时间。 values：用来指定在提取数据出来，需要提取哪些字段。默认情况下会把表中所有的字段全部都提取出来，可以使用values来进行指定，并且使用了values方法后，提取出的QuerySet中的数据类型不是模型，而是在values方法中指定的字段和值形成的字典： 123articles = Article.objects.values(\"title\",'content')for article in articles: print(article) 以上打印出来的article是类似于{&quot;title&quot;:&quot;abc&quot;,&quot;content&quot;:&quot;xxx&quot;}的形式。如果在values中没有传递任何参数，那么将会返回这个模型中所有的属性。 values_list：类似于values。只不过返回的QuerySet中，存储的不是字典，而是元组。示例代码如下： 12articles = Article.objects.values_list(\"id\",\"title\") print(articles) 那么在打印articles后，结果为&lt;QuerySet [(1,&#39;abc&#39;),(2,&#39;xxx&#39;),...]&gt;等。如果在values_list中只有一个字段。那么你可以传递flat=True来将结果扁平化。示例代码如下： 1234articles1 = Article.objects.values_list(\"title\")&gt;&gt; &lt;QuerySet [(\"abc\",),(\"xxx\",),...]&gt;articles2 = Article.objects.values_list(\"title\",flat=True)&gt;&gt; &lt;QuerySet [\"abc\",'xxx',...]&gt; defer：在一些表中，可能存在很多的字段，但是一些字段的数据量可能是比较庞大的，而此时你又不需要，比如我们在获取文章列表的时候，文章的内容我们是不需要的，因此这时候我们就可以使用defer来过滤掉一些字段。这个字段跟values有点类似，只不过defer返回的不是字典，而是模型。示例代码如下： 1234articles = list(Article.objects.defer(\"title\"))for sql in connection.queries: print('='*30) print(sql) 在看以上代码的sql语句，你就可以看到，查找文章的字段，除了title，其他字段都查找出来了。当然，你也可以使用article.title来获取这个文章的标题，但是会重新执行一个查询的语句。示例代码如下： 12345678articles = list(Article.objects.defer(\"title\"))for article in articles: # 因为在上面提取的时候过滤了title # 这个地方重新获取title，将重新向数据库中进行一次查找操作 print(article.title)for sql in connection.queries: print('='*30) print(sql) defer虽然能过滤字段，但是有些字段是不能过滤的，比如id，即使你过滤了，也会提取出来。 only：跟defer类似，只不过defer是过滤掉指定的字段，而only是只提取指定的字段。 select_related：在提取某个模型的数据的同时，也提前将相关联的数据提取出来。比如提取文章数据，可以使用select_related将author信息提取出来，以后再次使用article.author的时候就不需要再次去访问数据库了。可以减少数据库查询的次数。示例代码如下： 1234article = Article.objects.get(pk=1)&gt;&gt; article.author # 重新执行一次查询语句article = Article.objects.select_related(\"author\").get(pk=2)&gt;&gt; article.author # 不需要重新执行查询语句了 selected_related只能用在一对多或者一对一中，不能用在多对多或者多对一中。比如可以提前获取文章的作者，但是不能通过作者获取这个作者的文章，或者是通过某篇文章获取这个文章所有的标签。 prefetch_related：这个方法和select_related非常的类似，就是在访问多个表中的数据的时候，减少查询的次数。这个方法是为了解决多对一和多对多的关系的查询问题。比如要获取标题中带有hello字符串的文章以及他的所有标签，示例代码如下： 12345678910from django.db import connectionarticles = Article.objects.prefetch_related(\"tag_set\").filter(title__contains='hello')print(articles.query) # 通过这条命令查看在底层的SQL语句for article in articles: print(\"title:\",article.title) print(article.tag_set.all())# 通过以下代码可以看出以上代码执行的sql语句for sql in connection.queries: print(sql) 但是如果在使用article.tag_set的时候，如果又创建了一个新的QuerySet那么会把之前的SQL优化给破坏掉。比如以下代码： 1234567tags = Tag.obejcts.prefetch_related(\"articles\")for tag in tags: articles = tag.articles.filter(title__contains='hello') #因为filter方法会重新生成一个QuerySet，因此会破坏掉之前的sql优化# 通过以下代码，我们可以看到在使用了filter的，他的sql查询会更多，而没有使用filter的，只有两次sql查询for sql in connection.queries: print(sql) 那如果确实是想要在查询的时候指定过滤条件该如何做呢，这时候我们可以使用django.db.models.Prefetch来实现，Prefetch这个可以提前定义好queryset。示例代码如下： 123456789tags = Tag.objects.prefetch_related(Prefetch(\"articles\",queryset=Article.objects.filter(title__contains='hello'))).all()for tag in tags: articles = tag.articles.all() for article in articles: print(article)for sql in connection.queries: print('='*30) print(sql) 因为使用了Prefetch，即使在查询文章的时候使用了filter，也只会发生两次查询操作。 get：获取满足条件的数据。这个函数只能返回一条数据，并且如果给的条件有多条数据，那么这个方法会抛出MultipleObjectsReturned错误，如果给的条件没有任何数据，那么就会抛出DoesNotExit错误。所以这个方法在获取数据的只能，只能有且只有一条。 bulk_create：一次性创建多个数据。示例代码如下： 1234Tag.objects.bulk_create([ Tag(name='111'), Tag(name='222'),]) count：获取提取的数据的个数。如果想要知道总共有多少条数据，那么建议使用count，而不是使用len(articles)这种。因为count在底层是使用select count(*)来实现的，这种方式比使用len函数更加的高效。 返回int类型数据。 first和last：返回QuerySet中的第一条和最后一条数据。 exists：判断某个条件的数据是否存在。如果要判断某个条件的元素是否存在，那么建议使用exists，这比使用count或者直接判断QuerySet更有效得多。示例代码如下： 12345678if Article.objects.filter(title__contains='hello').exists(): print(True)比使用count更高效：if Article.objects.filter(title__contains='hello').count() &gt; 0: print(True)也比直接判断QuerySet更高效：if Article.objects.filter(title__contains='hello'): print(True) distinct：去除掉那些重复的数据。这个方法如果底层数据库用的是MySQL，那么不能传递任何的参数。比如想要提取所有销售的价格超过80元的图书，并且删掉那些重复的，那么可以使用distinct来帮我们实现，示例代码如下： 1books = Book.objects.filter(bookorder__price__gte=80).distinct() 需要注意的是，如果在distinct之前使用了order_by，那么因为order_by会提取order_by中指定的字段，因此再使用distinct就会根据多个字段来进行唯一化，所以就不会把那些重复的数据删掉。示例代码如下： 1orders = BookOrder.objects.order_by(\"create_time\").values(\"book_id\").distinct() 那么以上代码因为使用了order_by，即使使用了distinct，也会把重复的book_id提取出来。 update：执行更新操作，在SQL底层走的也是update命令。比如要将所有category为空的article的article字段都更新为默认的分类。示例代码如下： 1Article.objects.filter(category__isnull=True).update(category_id=3) 注意这个方法走的是更新的逻辑。所以更新完成后保存到数据库中不会执行save方法，因此不会更新auto_now设置的字段。 delete：删除所有满足条件的数据。删除数据的时候，要注意on_delete指定的处理方式。 该方法将返回被删除对象的总数量和一个字典，字典包含了每种被删除对象的类型和该类型的数量。如下所示： 12&gt;&gt;&gt; e.delete()(1, &#123;'weblog.Entry': 1&#125;) 也可以批量删除。每个QuerySet都有一个delete()方法，它能删除该QuepythonrySet的所有成员。例如： 12&gt;&gt;&gt; Entry.objects.filter(pub_date__year=2005).delete()(5, &#123;'webapp.Entry': 5&#125;) update:使用update()方法可以批量为QuerySet中所有的对象进行更新操作。 12# 更新所有2007年发布的entry的headlineEntry.objects.filter(pub_date__year=2007).update(headline='Everything is the same') 只可以对普通字段和ForeignKey字段使用这个方法。若要更新一个普通字段，只需提供一个新的常数值。若要更新ForeignKey字段，需设置新值为你想指向的新模型实例。例如： 123b = Blog.objects.get(pk=1)# 修改所有的Entry，让他们都属于bEntry.objects.all().update(blog=b) update方法会被立刻执行，并返回操作匹配到的行的数目（有可能不等于要更新的行的数量，因为有些行可能已经有这个新值了）。唯一的约束是：只能访问一张数据库表。你可以根据关系字段进行过滤，但你只能更新模型主表的字段。例如： 123b = Blog.objects.get(pk=1)# Update all the headlines belonging to this Blog. Entry.objects.select_related().filter(blog=b).update(headline='Everything is the same') 要注意的是update()方法会直接转换成一个SQL语句，并立刻批量执行。它不会运行模型的save()方法，或者产生pre_save或post_save信号（调用save()方法产生）或者服从auto_now字段选项。如果你想保存QuerySet中的每个条目并确保每个实例的save()方法都被调用，你不需要使用任何特殊的函数来处理。只需要迭代它们并调用save()方法： 12for item in my_queryset: item.save() update方法可以配合F表达式。这对于批量更新同一模型中某个字段特别有用。例如增加Blog中每个Entry的pingback个数： 1Entry.objects.all().update(n_pingbacks=F('n_pingbacks') + 1) 然而，与filter和exclude子句中的F()对象不同，在update中你不可以使用F()对象进行跨表操作，你只可以引用正在更新的模型的字段。如果你尝试使用F()对象引入另外一张表的字段，将抛出FieldError异常： 12# THIS WILL RAISE A FieldErrorEntry.objects.update(headline=F('blog__name')) ==update==:不能跨表更新 切片操作：有时候我们查找数据，有可能只需要其中的一部分。那么这时候可以使用切片操作来帮我们完成。QuerySet使用切片操作就跟列表使用切片操作是一样的。示例代码如下： 123books = Book.objects.all()[1:3]for book in books: print(book) 切片操作并不是把所有数据从数据库中提取出来再做切片操作。而是在数据库层面使用LIMIE和OFFSET来帮我们完成。所以如果只需要取其中一部分的数据的时候，建议使用切片操作。 查询操作查询一般就是使用filter、exclude以及get三个方法来实现。我们可以在调用这些方法的时候传递不同的参数来实现查询需求。在ORM层面，这些查询条件都是使用field+__+condition的方式来使用的。 exact：使用精确的=进行查找，如果提供的是一个None，那么在SQL层面就是被解释为NULL。 12article = Article.objects.get(id__exact=14)article = Article.objects.get(id__exact=None) iexact：在windows操作系统上。Mysql的排序规则(collation)无论是什么都是大小写不敏感的。在Linux操作系统上，Mysql的排序规则(collation)是utf8_bin那么就是大小写敏感的，iexact和exact可以认为没有区别 contains：大小写敏感，判断某个字段是否包含了某个数据。示例代码如下： 1articles = Article.objects.filter(title__contains='hello') 在翻译成SQL语句为如下： 1select ... where title like binary '%hello%'; 要注意的是，在使用contains的时候，翻译成的sql语句左右两边是有百分号的，意味着使用的是模糊查询。而exact翻译成sql语句左右两边是没有百分号的，意味着使用的是精确的查询。 icontains：contains的大小写不敏感版本 in：可以直接指定某个字段的是否在某个集合中。示例代码如下： 1articles = Article.objects.filter(id__in=[1,2,3]) 也可以通过其他的表的字段来判断是否在某个集合中。示例代码如下： 1categories = Category.objects.filter(article__id__in=[1,2,3]) 如果要判断相关联的表的字段，那么也是通过__来连接。并且在做关联查询的时候，不需要写models_set，直接使用模型的名字的小写化就可以了。比如通过分类去查找相应的文章，那么通过article__id__in就可以了，而不是写成article_set__id__in的形式。当然如果你不想使用默认的形式，可以在外键定义的时候传递related_query_name来指定反向查询的名字。示例代码如下： 12345class Category(models.Model): name = models.CharField(max_length=100) class Meta: db_table = 'category' 12345678910111213141516class Article(models.Model): title = models.CharField(max_length=200) content = models.TextField() cateogry = models.ForeignKey(\"Category\",on_delete=models.CASCADE,null=True,related_query_name='articles') class Meta: db_table = 'article' class Article(models.Model): title = models.CharField(max_length=200) content = models.TextField() cateogry = models.ForeignKey(\"Category\",on_delete=models.CASCADE,null=True,related_query_name='articles') class Meta: db_table = 'article' 因为在cateogry的ForeignKey中指定了related_query_name为articles，因此你不能再使用article来进行反向查询了。这时候就需要通过articles__id__in来进行反向查询。 反向查询是将模型名字小写化。比如article_in。可以通过related_query_name来指定自己的方式 反向应用是将模型名字小写化，然后再加上_set，比如article_set，可以通过related_name来指定自己的方式 并且，如果在做反向查询的时候，如果查询的字段就是模型的主键，那么可以省略掉这个字段，直接写成article__in就可以了，不需要这个id了。 in不仅仅可以指定列表/元组，还可以为QuerySet。比如要查询“文章标题中包含有hello的所有分类”，那么可以通过以下代码来实现： 1234articles = Article.objects.filter(title__icontains='hello')categories = Category.objects.filter(articles__in=articles)for cateogry in categories: print(cateogry) gt gte lt lte大于，大于等于，小于，小于等于 1articles = Article.objects.filter(id__lte=3) startswith：判断某个字段的值是否是以某个值开始的。大小写敏感。示例代码如下： 1articles = Article.objects.filter(title__startswith='hello') 以上代码的意思是提取所有标题以hello字符串开头的文章。将翻译成以下SQL语句： 1select ... where title like 'hello%' istartswith：类似于startswith，但是大小写是不敏感的。 endswith：判断某个字段的值是否以某个值结束。大小写敏感。示例代码如下： 1articles = Article.objects.filter(title__endswith='world') 以上代码的意思是提取所有标题以world结尾的文章。将翻译成以下SQL语句： 1select ... where title like '%world'; iendswith：类似于endswith，只不过大小写不敏感。 range：可以指定一个时间段。并且时间应该标记为aware时间，不然django会报警告。示例代码如下： 123start_time = make_aware(datetime(year=2018,month=4,day=4,hour=17,minute=0,second=0))end_time = make_aware(datetime(year=2018,month=4,day=4,hour=18,minute=0,second=0))articles = Article.objects.filter(create_time__range=(start_time,end_time)) ==注意==：虽然数据库中保存的时间是UTC时间但是操作时可以直接采用设置时区的时间，django会自动进行转换 可以使用django内置的make_aware将navie时间转化为aware时间 date：用年月日来进行过滤。如果想要使用这个过滤条件，那么前提必须要在MySQL中添加好那些时区文件。如何添加呢？参考教案。示例代码如下： 1articles = Article.objects.filter(create_time__date=datetime(year=2018,month=4,day=4)) year month day：表示根据年/月/日进行查找。示例代码如下： 1articles = Article.objects.filter(create_time__year__gte=2018) week_day：根据星期来进行查找。1表示星期天，7表示星期六，2-6代表的是星期一到星期五。比如要查找星期三的所有文章，那么可以通过以下代码来实现： 1articles = Article.objects.filter(create_time__week_day=4) time：根据分时秒来进行查找。如果要具体到秒，一般比较难匹配到，可以使用区间的方式来进行查找。区间使用range条件。比如想要获取17时/10分/27-28秒之间的文章，那么可以通过以下代码来实现： 123start_time = time(hour=17,minute=10,second=27)end_time = time(hour=17,minute=10,second=28)articles = Article.objects.filter(create_time__time__range=(start_time,end_time)) isnull：根据值是否为空进行查找。示例代码如下： 1articles = Article.objects.filter(pub_date__isnull=False) 以上的代码的意思是获取所有发布日期不为空的文章。将来翻译成SQL语句如下： 1select ... where pub_date is not null; regex iregex：大小写敏感和大小写不敏感的正则表达式。示例代码如下： 1articles = Article.objects.filter(title__regex=r'^hello') 以上代码的意思是提取所有标题以hello字符串开头的文章。将翻译成以下的SQL语句： 1select ... where title regexp binary '^hello'; iregex是大小写不敏感的。 聚合函数 所有的聚合函数都是放在django.db.models下面。 聚合函数不能够单独的执行，需要放在一些可以执行聚合函数的方法下面中去执行。比如aggregate。示例代码如下： 1result = Book.objects.aggregate(Avg(\"price\")) 聚合函数执行完成后，给这个聚合函数的值取个名字。取名字的规则，默认是filed+__+聚合函数名字形成的。比如以上代码形成的名字叫做price__avg。如果不想使用默认的名字，那么可以在使用聚合函数的时候传递关键字参数进去，参数的名字就是聚合函数执行完成的名字。实示例代码如下： 1result = Book.objects.aggregate(avg=Avg(\"price\")) 以上传递了关键字参数avg=Avg(&quot;price&quot;)，那么以后Avg聚合函数执行完成的名字就叫做avg。 aggregate：这个方法不会返回一个QuerySet对象，而是返回一个字典。这个字典中的key就是聚合函数的名字，值就是聚合函数执行后的结果。 aggregate和annotate的相同和不同： 相同：这两个方法都可以执行聚合函数。 不同： aggregate返回的是一个字典，在这个字典中存储的是这个聚合函数执行的结果。而annotate返回的是一个QuerySet对象，并且会在查找的模型上添加一个聚合函数的属性。 aggregate不会做分组，而annotate会使用group by子句进行分组，只有调用了group by子句，才能对每一条数据求聚合函数的值。 Count：用来求某个数据的个数。比如要求所有图书的数量，那么可以使用以下代码： 1result = Book.objects.aggregate(book_nums=Count(\"id\")) 并且Count可以传递distinct=True参数，用来剔除那些重复的值，只保留一个。比如要获取作者表中，不同邮箱的个数，那么这时候可以使用distinct=True。示例代码如下： 1result = Author.objects.aggregate(email_nums=Count('email',distinct=True)) Max和Min：求指定字段的最大值和最小值。示例代码如下： 1result = Author.objects.aggregate(max=Max(\"age\"),min=Min(\"age\")) Sum：求某个字段值的总和。示例代码如下： 1result = BookOrder.objects.aggregate(total=Sum('price')) aggregate和annotate方法可以在任何的QuerySet对象上调用。因此只要是返回了QuerySet对象，那么就可以进行链式调用。比如要获取2018年度的销售总额，那么可以先过滤年份，再求聚合函数。示例代码如下： 1BookOrder.objects.filter(create_time__year=2018).aggregate(total=Sum('price')) F表达式和Q表达式Q表达式：使用Q表达式包裹查询条件，可以在条件之间进行多种操作。与/或非等，从而实现一些复杂的查询操作。例子如下： 查找价格大于100，并且评分达到4.85以上的图书： 1234# 不使用Q表达式的books = Book.objects.filter(price__gte=100,rating__gte=4.85)# 使用Q表达式的books = Book.objects.filter(Q(price__gte=100)&amp;Q(rating__gte=4.85)) 查找价格低于100元，或者评分低于4分的图书： 1books = Book.objects.filter(Q(price__gte=100)&amp;Q(rating__gte=4.85)) 获取价格大于100，并且图书名字中不包含”传“字的图书： 1books = Book.objects.filter(Q(price__gte=100)&amp;~Q(name__icontains='传')) 当关键字参数和Q对象组合使用时，Q对象必须放在前面，如下例子： 12Poll.objects.get(Q(pub_date&#x3D;date(2005, 5, 2)) | Q(pub_date&#x3D;date(2005, 5, 6)),question__startswith&#x3D;&#39;Who&#39;,) 如果关键字参数放在Q对象的前面，则会报错。 F表达式：到目前为止的例子中，我们都是将模型字段与常量进行比较。但是，如果你想将模型的一个字段与同一个模型的另外一个字段进行比较该怎么办？ 使用Django提供的F表达式！ 例如，为了查找comments数目多于pingbacks数目的Entry，可以构造一个F()对象来引用pingback数目，并在查询中使用该F()对象： 12from django.db.models import FEntry.objects.filter(n_comments__gt=F('n_pingbacks')) Django支持对F()对象进行加、减、乘、除、取模以及幂运算等算术操作。两个操作数可以是常数和其它F()对象。例如查找comments数目比pingbacks两倍还要多的Entry，我们可以这么写： 1Entry.objects.filter(n_comments__gt=F('n_pingbacks') * 2) 为了查询rating比pingback和comment数目总和要小的Entry，我们可以这么写： 1Entry.objects.filter(rating__lt=F('n_comments') + F('n_pingbacks')) 你还可以在F()中使用双下划线来进行跨表查询。例如，查询author的名字与blog名字相同的Entry： 1Entry.objects.filter(authors__name=F('blog__name')) 对于date和date/time字段，还可以加或减去一个timedelta对象。下面的例子将返回发布时间超过3天后被修改的所有Entry： 12from datetime import timedeltaEntry.objects.filter(mod_date__gt=F('pub_date') + timedelta(days=3)) ORM模型迁移makemigrations：将模型生成迁移脚本。模型所在的app，必须放在settings.py中的INSTALLEN_APPS中。这个命令有以下几个常用选项： app_label:后面可以跟一个或者多个app，那么就会只针对这几个app生成迁移脚本。如果没有任何的app_label，那么会检查INSTALLED_APPS中所有的app下的模型，如果发生了更改就会生成迁移脚本。 1python manage.py makemigrations book –name：给这个迁移脚本指定一个名字。 1python manage.py makemigrations book --name\"remove_content\" –empty： 生成一个空的迁移脚本。如果你想写自己的迁移脚本，可以使用这个命令来实现一个空的文件，然后自己再在文件中写迁移脚本。 migrate： app_label：同上 –fake： 可以将指定的迁移脚本名字添加到数据库中。但是并不会把迁移脚本转换为SQL语句，修改数据库中的表。 –fake-initial：将第一次生成的迁移文件版本号记录在数据库中。但并不会真正的执行迁移脚本。 showmigrations：查看某个app下的迁移文件。如果后面没有app，那么将查看INSTALLED_APPS中所有的迁移文件。 sqlmigrate：查看某个迁移文件在映射到数据库中的时候，转换的SQL语句。 django模型迁移的步骤： 迁移判定，将你的项目中的迁移脚本同数据库中的表django_migreations判断是否有新的迁移，django会执行没有的迁移脚本。","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://chrisxd.gitee.io/blog/tags/%E7%AE%97%E6%B3%95/"}],"author":"chris"},{"title":"leetcode题解/java","slug":"leetcode题解/java","date":"2020-06-28T04:47:04.255Z","updated":"2020-06-28T08:01:19.548Z","comments":true,"path":"2020/06/28/leetcode题解/java/","link":"","permalink":"http://chrisxd.gitee.io/blog/2020/06/28/leetcode%E9%A2%98%E8%A7%A3/java/","excerpt":"","text":"java数据类型12float f1 = 1.65; //会报错，1.65默认为double类型，不能直接赋值给floatfloat f1 = 1.65F;//正确 位操作符 字符串连接符 ==注意==：char类型要看成两个字节的整数类型","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-06-28T04:43:32.031Z","updated":"2020-06-28T04:43:32.031Z","comments":true,"path":"2020/06/28/hello-world/","link":"","permalink":"http://chrisxd.gitee.io/blog/2020/06/28/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://chrisxd.gitee.io/blog/tags/%E7%AE%97%E6%B3%95/"}]}