<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/blog/img/site.png">
  <link rel="icon" type="image/png" href="/blog/img/site.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="chris">
  <meta name="keywords" content="">
  <title>leetcode题解 - chris的blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/blog/lib/hint/hint.min.css" />

  
    
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/blog/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/blog/js/utils.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/blog/">&nbsp;<strong>Chirs</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/about/">
                <i class="iconfont icon-codeforces"></i>
                深色模式
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/blog/img/mydefault.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-06-28 15:57">
      2020年6月28日 下午
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      10.5k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      125
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
              <p class="note note-info">
                
                  本文最后更新于：2 天前
                
              </p>
            
            <article class="markdown-body">
              <h1 id="django模型"><a href="#django模型" class="headerlink" title="django模型"></a>django模型</h1><a id="more"></a>

<h2 id="django配置MYSQL数据库"><a href="#django配置MYSQL数据库" class="headerlink" title="django配置MYSQL数据库"></a>django配置MYSQL数据库</h2><pre><code class="hljs python">DATABASES = &#123;
    <span class="hljs-string">'default'</span>: &#123;
        <span class="hljs-string">'ENGINE'</span>: <span class="hljs-string">'django.db.backends.mysql'</span>,
        <span class="hljs-string">'NAME'</span>: <span class="hljs-string">'blog'</span>,
        <span class="hljs-string">'HOST'</span>: <span class="hljs-string">'127.0.0.1'</span>,
        <span class="hljs-string">'USER'</span>: <span class="hljs-string">'root'</span>,
        <span class="hljs-string">'PASSWORD'</span>: <span class="hljs-string">'root'</span>,
        <span class="hljs-string">'PORT'</span>: <span class="hljs-string">'3306'</span>
    &#125;
&#125;</code></pre>



<p>每一个模型都是继承自<code>django.db.models.Model</code>，模型的每一个属性相当于数据库的一个字段，每一个模型的映射一张数据库表。</p>
<h2 id="常用字段-filed"><a href="#常用字段-filed" class="headerlink" title="常用字段 filed"></a>常用字段 filed</h2><table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>AutoField</code></td>
<td>一个自动增长的整形类型的字段，通常你不需要自己添加，如果在你的模型中没有定义主键，Django会自动为你添加一个名为<code>id</code>的从1开始自增长的主键</td>
</tr>
<tr>
<td><code>BooleanField</code></td>
<td>布尔值类型，在数据库中表示为<code>tinyint</code>类型。默认值为null，如果要接收<code>null</code>值，需要使用<code>NullBooleanField</code>字段。在HTML中展示为checkbox</td>
</tr>
<tr>
<td><code>CharField</code></td>
<td>在数据库中为<code>varchar</code>类型，必须指定<code>max_length</code>属性，在HTML中展示为 text input</td>
</tr>
<tr>
<td><code>TextField</code></td>
<td>用来保存大量文本内容，不限长度，在HTML中变现为 textarea</td>
</tr>
<tr>
<td><code>IntegerField</code></td>
<td>整数类型，取值范围-2147483648到2147483647（-2的31次方-2的31次方-1）。在HTML中表现为number Input标签。</td>
</tr>
<tr>
<td><code>EmailField</code></td>
<td>类似于<code>charfield</code>，在数据库底层也是一个<code>vechar</code>类型，默认最大长度为254个字符。但是虽然其为email类型，在保存到数据库中并不会做验证，只有用<code>ModelForm</code>进行表单验证的时候才起作用。</td>
</tr>
<tr>
<td><code>DateField</code></td>
<td>日期类型。在<code>Python</code>中是<code>datetime.date</code>类型，可以记录年月日。在映射到数据库中也是<code>date</code>类型。使用这个<code>Field</code>可以传递以下几个参数：<br>    1. <code>auto_now</code>:在每次这个数据保存的时候，都使用当前的时间。比如作为一个记录修改日期的字段，可以将这个属性     设置为<code>True</code>。<br>    2.<code>auto_now_add</code>：在每次数据第一次被添加进去的时候，都使用当前的时间。比如作为一个记录第一次入库的字段，可以将这个属性设置为<code>True</code>。</td>
</tr>
<tr>
<td><code>DateTimeField</code></td>
<td>日期时间类型。 在<code>Python</code>中是<code>datetime.datetime</code>类型，可以记录年月日时分秒，参数同上</td>
</tr>
<tr>
<td><code>TimeField</code></td>
<td>时间类型。在<code>Python</code>中是<code>datetime.time</code>类型,也有<code>auto_now</code>和<code>auto_now_add</code>两个参数。</td>
</tr>
<tr>
<td><code>DecimalField</code></td>
<td><code>models.DecimalField(max_digits=None, decimal_places=None[, **options])</code><br>使用 <code>Decimal</code> 实例表示固定精度的十进制数的字段。它有两个必须的参数：<br><code>max_digits</code>：数字允许的最大位数<br><code>decimal_places</code>：小数的最大位数<br>例如，要存储的数字最大长度为3位，而带有两个小数位，可以使用：<br><code>models.DecimalField( max_digits=3, decimal_places=2,...)</code></td>
</tr>
</tbody></table>
<p>==注意：==在mysql 5.0以上的版本时关于字符长度中文字符和英文字符一样都是字面大小，不需要转化。</p>
<p>==补充：关于<code>aware</code>时间和<code>navie</code>时间==</p>
<blockquote>
<ul>
<li>什么是<code>navie</code>时间？什么是<code>aware</code>时间？</li>
</ul>
<p><code>navie</code>时间：朴素的时间，不知道自己的时区</p>
<p><code>aware</code>时间：清醒的时间，知道自己的时区</p>
<ul>
<li>pytz库：</li>
</ul>
<p>一个关于处理时区的库</p>
<pre><code class="hljs python">&gt;<span class="hljs-keyword">import</span> pytz
&gt;utc_timezone = pytz.timezone(<span class="hljs-string">'UTC'</span>)<span class="hljs-comment">#定义一个UTC的时区时间</span></code></pre>

<ul>
<li>astimezone方法：</li>
</ul>
<p>将一个时区的时间转化为另外一个时区的时间。这个方法之内被<code>aware</code>类型的时间调用</p>
<p>不能被<code>navie</code>类型的时间调用</p>
<pre><code class="hljs python">&gt;<span class="hljs-keyword">import</span> pytz
&gt;<span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime <span class="hljs-comment">#python中处理时间的包</span>
&gt;now = datetime.now()<span class="hljs-comment">#这是一个navie类型的时间</span>
&gt;utc_timezone = pytz.timezone(<span class="hljs-string">'UTC'</span>)<span class="hljs-comment">#定义一个UTC的时区时间</span>
&gt;utc_now = now .astimezone(utc_timezone)<span class="hljs-comment">#将当前时间转换化为UTC时区的时间</span>
&gt;&gt;ValueError:astimezone()cannot be applied to a native time
&gt;<span class="hljs-comment">#抛出异常</span></code></pre>

<ul>
<li>replace方法：</li>
</ul>
<p>用来改变时间对象的一个属性</p>
<pre><code class="hljs python">&gt;now = now.replace(tzinfo=pytz.timezone(<span class="hljs-string">'Asia/Shanghai'</span>))
&gt;utc_now = now.astimezone(utc_timezone)
&gt;<span class="hljs-comment">#这是就可以正确转换</span></code></pre>

<ul>
<li>django.utils.timezone.now方法：</li>
</ul>
<p>会根据<code>settings.py</code>中是否设置类<code>USE_TZ=true</code>获取当前的时间。如果设置了，那么会获取一个<code>navie</code>类型的<code>UTC</code>时间。如果没有设置，那么会获取一个<code>navie</code>类型的时间</p>
<ul>
<li>django.utils.timezone.localtime方法：</li>
</ul>
<p>会根据<code>setting.py</code>中的<code>TIME_ZONE</code>来将一个<code>aware</code>类型的时间转化为<code>TIME_ZONE</code>中指定的时区的时间</p>
<ul>
<li>对于在数据库中保存时间的时候就需要和本地时间一致的问题，除了将<code>USE_TZ=false</code>和手动添加8小时意外还没发现太好的办法</li>
</ul>
</blockquote>
<h2 id="字段常用属性"><a href="#字段常用属性" class="headerlink" title="字段常用属性"></a>字段常用属性</h2><h3 id="null"><a href="#null" class="headerlink" title="null"></a><code>null</code></h3><p>默认false，当设置为true时,该字段为空时django会在数据中将该字段设置为null</p>
<p>避免在基于字符串的字段中使用，对于无数据django的管理是使用空字符串而不是null</p>
<h3 id="blank"><a href="#blank" class="headerlink" title="blank"></a><code>blank</code></h3><p>默认flase，设置为true时该字段允许为空</p>
<p>==注意==：和null不同，null是数据库相关的，blank是验证相关的，如果blank=true，表单验证将会允许输入空值</p>
<h3 id="db-column"><a href="#db-column" class="headerlink" title="db_column"></a><code>db_column</code></h3><p>设置这个字段在中的名字，如果没有设置将默认采用字段名字</p>
<h3 id="choices"><a href="#choices" class="headerlink" title="choices"></a><code>choices</code></h3><p>在HTMl中渲染为一个select box，需要先提供一个二维的二元元组，第一个元素表示存在数据库内真实的值，第二个表示页面上显示的具体内容。在浏览器页面上将显示第二个元素的值。例如： </p>
<pre><code class="hljs python">YEAR_IN_SCHOOL_CHOICES = (
        (<span class="hljs-string">'FR'</span>, <span class="hljs-string">'Freshman'</span>),
        (<span class="hljs-string">'SO'</span>, <span class="hljs-string">'Sophomore'</span>),
        (<span class="hljs-string">'JR'</span>, <span class="hljs-string">'Junior'</span>),
        (<span class="hljs-string">'SR'</span>, <span class="hljs-string">'Senior'</span>),
        (<span class="hljs-string">'GR'</span>, <span class="hljs-string">'Graduate'</span>),
    )</code></pre>

<p> 一般来说，最好将选项定义在类里，并取一个直观的名字，如下所示： </p>
<pre><code class="hljs python"><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span><span class="hljs-params">(models.Model)</span>:</span>
    FRESHMAN = <span class="hljs-string">'FR'</span>
    SOPHOMORE = <span class="hljs-string">'SO'</span>
    JUNIOR = <span class="hljs-string">'JR'</span>
    SENIOR = <span class="hljs-string">'SR'</span>
    YEAR_IN_SCHOOL_CHOICES = (
        (FRESHMAN, <span class="hljs-string">'Freshman'</span>),
        (SOPHOMORE, <span class="hljs-string">'Sophomore'</span>),
        (JUNIOR, <span class="hljs-string">'Junior'</span>),
        (SENIOR, <span class="hljs-string">'Senior'</span>),
    )
    year_in_school = models.CharField(
        max_length=<span class="hljs-number">2</span>,
        choices=YEAR_IN_SCHOOL_CHOICES,
        default=FRESHMAN,
    )

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_upperclass</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self.year_in_school <span class="hljs-keyword">in</span> (self.JUNIOR, self.SENIOR)</code></pre>

<p> 要获取一个choices的第二元素的值，可以使用<code>get_FOO_display()</code>方法，其中的FOO用字段名代替。对于下面的例子： </p>
<pre><code class="hljs python"><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><span class="hljs-params">(models.Model)</span>:</span>
    SHIRT_SIZES = (
    (<span class="hljs-string">'S'</span>, <span class="hljs-string">'Small'</span>),
    (<span class="hljs-string">'M'</span>, <span class="hljs-string">'Medium'</span>),
    (<span class="hljs-string">'L'</span>, <span class="hljs-string">'Large'</span>),
    )
    name = models.CharField(max_length=<span class="hljs-number">60</span>)
    shirt_size = models.CharField(max_length=<span class="hljs-number">1</span>, choices=SHIRT_SIZES)
<span class="hljs-comment">#使用方法：</span>

<span class="hljs-meta">&gt;&gt;&gt; </span>p = Person(name=<span class="hljs-string">"Fred Flintstone"</span>, shirt_size=<span class="hljs-string">"L"</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>p.save()
<span class="hljs-meta">&gt;&gt;&gt; </span>p.shirt_size
<span class="hljs-string">'L'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>p.get_shirt_size_display()
<span class="hljs-string">'Large'</span></code></pre>

<h3 id="default"><a href="#default" class="headerlink" title="default"></a><code>default</code></h3><p>字段的默认值，可以是值或者是一个可调用对象。如果是可调用对象，那么每次创建新对象时都会调用。 </p>
<h3 id="error-messages"><a href="#error-messages" class="headerlink" title="error_messages"></a><code>error_messages</code></h3><p>用于自定义错误信息。参数接收字典类型的值。字典的键可以是<code>null</code>、 <code>blank</code>、 <code>invalid</code>、 <code>invalid_choice</code>、 <code>unique</code>和<code>unique_for_date</code>其中的一个。</p>
<h3 id="help-text"><a href="#help-text" class="headerlink" title="help_text"></a><code>help_text</code></h3><p>渲染为HTML时额外显示在表单组件上的帮助文档</p>
<h3 id="primary-key"><a href="#primary-key" class="headerlink" title="primary_key"></a><code>primary_key</code></h3><p>主键。 <code>primary_key=True</code>隐含<code>null=False</code>和<code>unique=True</code>的意思。一个模型中只能有一个主键字段！</p>
<h3 id="unique"><a href="#unique" class="headerlink" title="unique"></a><code>unique</code></h3><p>设为True时，在整个表内该字段的数据不可重复，否则会报错。</p>
<h2 id="模型元数据Meta"><a href="#模型元数据Meta" class="headerlink" title="模型元数据Meta"></a>模型元数据Meta</h2><p>在模型类中，可以指定元数据类<code>Meta</code>来配置模型的基本信息</p>
<pre><code class="hljs python"><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ox</span><span class="hljs-params">(models.Model)</span>:</span>
    horn_length = models.IntegerField()

    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>:</span>         <span class="hljs-comment"># 注意，是模型的子类，要缩进！</span>
        ordering = [<span class="hljs-string">"horn_length"</span>]
        verbose_name_plural = <span class="hljs-string">"oxen"</span></code></pre>

<h3 id="db-table"><a href="#db-table" class="headerlink" title="db_table"></a><code>db_table</code></h3><p>指定在数据库中，当前模型生成的数据表的表名。比如：</p>
<pre><code class="hljs python">db_table = <span class="hljs-string">'my_freinds'</span></code></pre>

<h3 id="verbose-name"><a href="#verbose-name" class="headerlink" title="verbose_name"></a><code>verbose_name</code></h3><p>最常用的元数据之一！用于设置模型对象的直观、人类可读的名称。可以用中文。例如：</p>
<pre><code class="hljs ini"><span class="hljs-attr">verbose_name</span> = <span class="hljs-string">"story"</span>
<span class="hljs-attr">verbose_name</span> = <span class="hljs-string">"披萨"</span></code></pre>

<p>如果你不指定它，那么Django会使用小写的模型名作为默认值。</p>
<h3 id="verbose-name-plural"><a href="#verbose-name-plural" class="headerlink" title="verbose_name_plural"></a><code>verbose_name_plural</code></h3><p><code>verbose_name</code>的复数，默认是在后面加个<code>s</code></p>
<h3 id="ordering"><a href="#ordering" class="headerlink" title="ordering"></a><code>ordering</code></h3><p>设置在提取数据的排序方式。后面章节会讲到如何查找数据。比如我想在查找数据的时候根据添加的时间排序 </p>
<pre><code class="hljs python">ordering = [<span class="hljs-string">'pub_date'</span>]             <span class="hljs-comment"># 表示按'pub_date'字段进行升序排列</span>
ordering = [<span class="hljs-string">'-pub_date'</span>]            <span class="hljs-comment"># 表示按'pub_date'字段进行降序排列</span>
ordering = [<span class="hljs-string">'-pub_date'</span>, <span class="hljs-string">'author'</span>]  <span class="hljs-comment"># 表示先按'pub_date'字段进行降序排列，再按`author`字段进行升序排列。</span></code></pre>

<h3 id="default-related-name"><a href="#default-related-name" class="headerlink" title="default_related_name"></a><code>default_related_name</code></h3><h2 id="外键和表关系"><a href="#外键和表关系" class="headerlink" title="外键和表关系"></a>外键和表关系</h2><h3 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h3><p>类定义为<code>class ForeignKey(to,on_delete,**options)</code>。第一个参数是引用的是哪个模型，第二个参数是在使用外键引用的模型数据被删除了，这个字段该如何处理，比如有<code>CASCADE</code>、<code>SET_NULL</code>等。这里以一个实际案例来说明。比如有一个<code>User</code>和一个<code>Article</code>两个模型。一个<code>User</code>可以发表多篇文章，一个<code>Article</code>只能有一个<code>Author</code>，并且通过外键进行引用。那么相关的示例代码如下：</p>
<pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span><span class="hljs-params">(models.Model)</span>:</span>
    username = models.CharField(max_length=<span class="hljs-number">20</span>)
    password = models.CharField(max_length=<span class="hljs-number">100</span>)


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Article</span><span class="hljs-params">(models.Model)</span>:</span>
    title = models.CharField(max_length=<span class="hljs-number">100</span>)
    content = models.TextField()

    author = models.ForeignKey(<span class="hljs-string">"User"</span>,on_delete=models.CASCADE)</code></pre>

<p>以上使用<code>ForeignKey</code>来定义模型之间的关系。即在<code>article</code>的实例中可以通过<code>author</code>属性来操作对应的<code>User</code>模型。这样使用起来非常的方便。示例代码如下：</p>
<pre><code class="hljs python">article = Article(title=<span class="hljs-string">'abc'</span>,content=<span class="hljs-string">'123'</span>)
author = User(username=<span class="hljs-string">'张三'</span>,password=<span class="hljs-string">'111111'</span>)
author.save()<span class="hljs-comment">#在指定外键之前，应当先将引用的外键数据保存在数据库中</span>
article.author = author
article.save()

<span class="hljs-comment"># 修改article.author上的值</span>
article.author.username = <span class="hljs-string">'李四'</span>
article.save()</code></pre>

<p>为什么使用了<code>ForeignKey</code>后，就能通过<code>author</code>访问到对应的<code>user</code>对象呢。因此在底层，<code>Django</code>为<code>Article</code>表添加了一个<code>属性名_id</code>的字段（比如author的字段名称是author_id），这个字段是一个外键，记录着对应的作者的主键。以后通过<code>article.author</code>访问的时候，实际上是先通过<code>author_id</code>找到对应的数据，然后再提取<code>User</code>表中的这条数据，形成一个模型。</p>
<p>如果想要引用另外一个<code>app</code>的模型，那么应该在传递<code>to</code>参数的时候，使用<code>app.model_name</code>进行指定。以上例为例，如果<code>User</code>和<code>Article</code>不是在同一个<code>app</code>中，那么在引用的时候的示例代码如下：</p>
<pre><code class="hljs python"><span class="hljs-comment"># User模型在user这个app中</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span><span class="hljs-params">(models.Model)</span>:</span>
    username = models.CharField(max_length=<span class="hljs-number">20</span>)
    password = models.CharField(max_length=<span class="hljs-number">100</span>)

<span class="hljs-comment"># Article模型在article这个app中</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Article</span><span class="hljs-params">(models.Model)</span>:</span>
    title = models.CharField(max_length=<span class="hljs-number">100</span>)
    content = models.TextField()

    author = models.ForeignKey(<span class="hljs-string">"user.User"</span>,on_delete=models.CASCADE)</code></pre>

<p>如果模型的外键引用的是本身自己这个模型，那么<code>to</code>参数可以为<code>&#39;self&#39;</code>，或者是这个模型的名字。在论坛开发中，一般评论都可以进行二级评论，即可以针对另外一个评论进行评论，那么在定义模型的时候就需要使用外键来引用自身。示例代码如下：</p>
<pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Comment</span><span class="hljs-params">(models.Model)</span>:</span>
    content = models.TextField()
    origin_comment = models.ForeignKey(<span class="hljs-string">'self'</span>,on_delete=models.CASCADE,null=<span class="hljs-literal">True</span>)
    <span class="hljs-comment"># 或者</span>
    <span class="hljs-comment"># origin_comment = models.ForeignKey('Comment',on_delete=models.CASCADE,null=True)</span></code></pre>

<h3 id="外键删除操作："><a href="#外键删除操作：" class="headerlink" title="外键删除操作："></a>外键删除操作：</h3><p>如果一个模型使用了外键。那么在对方那个模型被删掉后，该进行什么样的操作。可以通过<code>on_delete</code>来指定。可以指定的类型如下：</p>
<ol>
<li><code>CASCADE</code>：级联操作。如果外键对应的那条数据被删除了，那么这条数据也会被删除。</li>
<li><code>PROTECT</code>：受保护。即只要这条数据引用了外键的那条数据，那么就不能删除外键的那条数据。</li>
<li><code>SET_NULL</code>：设置为空。如果外键的那条数据被删除了，那么在本条数据上就将这个字段设置为空。如果设置这个选项，前提是要指定这个字段可以为空。</li>
<li><code>SET_DEFAULT</code>：设置默认值。如果外键的那条数据被删除了，那么本条数据上就将这个字段设置为默认值。如果设置这个选项，前提是要指定这个字段一个默认值。</li>
<li><code>SET()</code>：如果外键的那条数据被删除了。那么将会获取<code>SET</code>函数中的值来作为这个外键的值。<code>SET</code>函数可以接收一个可以调用的对象（比如函数或者方法），如果是可以调用的对象，那么会将这个对象调用后的结果作为值返回回去。</li>
<li><code>DO_NOTHING</code>：不采取任何行为。一切全看数据库级别的约束。</li>
</ol>
<p><strong>以上这些选项只是Django级别的，数据库级别按照数据库设置来</strong></p>
<p>mysql数据库删除时有四种可选项：</p>
<ul>
<li><p><code>RESTRICT</code>(默认值,类似django的<code>PROTECT</code>), </p>
</li>
<li><p><code>NO ACTION</code>(类似<code>RESTRICT</code>) </p>
</li>
<li><p><code>CASCADE</code>(同django) </p>
</li>
<li><p><code>SET NULL</code>(同django)</p>
</li>
</ul>
<h3 id="表关系"><a href="#表关系" class="headerlink" title="表关系"></a>表关系</h3><p>表之间的关系都是通过外键来进行关联的。而表之间的关系，无非就是三种关系：一对一、一对多（多对一）、多对多等。</p>
<h4 id="一对多或多对一"><a href="#一对多或多对一" class="headerlink" title="一对多或多对一"></a>一对多或多对一</h4><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForeignKey</span><span class="hljs-params">(to, on_delete, **options)</span>[<span class="hljs-title">source</span>]</span></code></pre>

<ol>
<li><p>应用场景：比如文章和作者之间的关系。一个文章只能由一个作者编写，但是一个作者可以写多篇文章。文章和作者之间的关系就是典型的多对一的关系。</p>
</li>
<li><p>实现方式：一对多或者多对一，都是通过<code>ForeignKey</code>来实现的。还是以文章和作者的案例进行讲解。</p>
<pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span><span class="hljs-params">(models.Model)</span>:</span>
    username = models.CharField(max_length=<span class="hljs-number">20</span>)
    password = models.CharField(max_length=<span class="hljs-number">100</span>)
   
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Article</span><span class="hljs-params">(models.Model)</span>:</span>
    title = models.CharField(max_length=<span class="hljs-number">100</span>)
    content = models.TextField()
    author = models.ForeignKey(<span class="hljs-string">"User"</span>,on_delete=models.CASCADE)</code></pre>

<p>那么以后在给<code>Article</code>对象指定<code>author</code>，就可以使用以下代码来完成：</p>
<pre><code class="hljs python">article = Article(title=<span class="hljs-string">'abc'</span>,content=<span class="hljs-string">'123'</span>)
author = User(username=<span class="hljs-string">'zhiliao'</span>,password=<span class="hljs-string">'111111'</span>)
<span class="hljs-comment"># 要先保存到数据库中</span>
author.save()
article.author = author
article.save()</code></pre>

<p>并且如果要实现用户对文章的反向引用可以使用<code>artivle_set</code>来实现，示例代码如下：</p>
<pre><code class="hljs python">user = User.objects.first()
<span class="hljs-comment"># 获取第一个用户写的所有文章</span>
articles = user.article_set.all()
<span class="hljs-keyword">for</span> article <span class="hljs-keyword">in</span> articles:
    print(article)</code></pre>

<p><code>article_set</code>为<code>django</code>默认为被外键引用的对象添加的<code>Queryset</code>类型的属性可以通过<code>Foreignkey</code>的<code>releted_name</code>重新指定该属性的名字(<code>article_set</code>-&gt;<code>artivles</code>)</p>
</li>
</ol>
<h4 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h4><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OneToOneField</span><span class="hljs-params">(to, on_delete, parent_link=False, **options)</span>[<span class="hljs-title">source</span>]</span></code></pre>

<ol>
<li><p>在Django中一对一是通过<code>models.OnetToOneField</code>来实现的。这个<code>OneToOneField</code>其实本质上就是一个外键，只不过这个外键有一个<code>唯一约束（unique key）</code>，来实现一对一。</p>
</li>
<li><p>以后如果想要反向引用，那么是通过引用的模型的名字转换为小写的形式进行访问。比如以下模型：</p>
<pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FrontUser</span><span class="hljs-params">(models.Model)</span>:</span>
    username = models.CharField(max_length=<span class="hljs-number">200</span>)

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserExtension</span><span class="hljs-params">(models.Model)</span>:</span>
    school = models.CharField(max_length=<span class="hljs-number">100</span>)
    user = models.OneToOneField(<span class="hljs-string">"FrontUser"</span>,on_delete=models.CASCADE)

<span class="hljs-comment"># 通过userextension来访问UserExtension对象</span>
user = FrontUser.objects.first()
print(user.userextension)</code></pre>

<p><code>UserExtension</code>的对象，可以通过<code>user</code>来访问到对应的user对象。并且<code>FrontUser</code>对象可以使用<code>userextension</code>来访问对应的<code>UserExtension</code>对象。<br>如果不想使用Django默认的引用属性名字。那么可以在<code>OneToOneField</code>中添加一个<code>related_name</code>参数。示例代码如下：</p>
<pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FrontUser</span><span class="hljs-params">(models.Model)</span>:</span>
    username = models.CharField(max_length=<span class="hljs-number">200</span>)

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserExtension</span><span class="hljs-params">(models.Model)</span>:</span>
    school = models.CharField(max_length=<span class="hljs-number">100</span>)
    user = models.OneToOneField(<span class="hljs-string">"FrontUser"</span>,on_delete=models.CASCADE,related_name=<span class="hljs-string">'extension'</span>)

<span class="hljs-comment"># 通过extension来访问到UserExtension对象</span>
user = FrontUser.objects.first()
print(user.extension)</code></pre>

<p>那么以后就<code>FrontUser</code>的对象就可以通过<code>extension</code>属性来访问到对应的<code>UserExtension</code>对象。</p>
</li>
</ol>
<h4 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h4><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ManyToManyField</span><span class="hljs-params">(to, **options)</span>[<span class="hljs-title">source</span>]</span></code></pre>

<ol>
<li><p>应用场景：比如文章和标签的关系。一篇文章可以有多个标签，一个标签可以被多个文章所引用。因此标签和文章的关系是典型的多对多的关系。</p>
</li>
<li><p>实现方式：<code>Django</code>为这种多对多的实现提供了专门的<code>Field</code>。叫做<code>ManyToManyField</code>。还是拿文章和标签为例进行讲解。示例代码如下：</p>
<pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Article</span><span class="hljs-params">(models.Model)</span>:</span>
    title = models.CharField(max_length=<span class="hljs-number">100</span>)
    content = models.TextField()
    tags = models.ManyToManyField(<span class="hljs-string">"Tag"</span>,related_name=<span class="hljs-string">"articles"</span>)

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tag</span><span class="hljs-params">(models.Model)</span>:</span>
 name = models.CharField(max_length=<span class="hljs-number">50</span>)</code></pre>

<p>在数据库层面，实际上<code>Django</code>是为这种多对多的关系建立了一个中间表。这个中间表分别定义了两个外键，引用到<code>article</code>和<code>tag</code>两张表的主键。中间表的表名默认为：app名_model名_模型多对多字段名</p>
</li>
<li><p><strong>自定义中间表</strong></p>
<p>一般情况，普通的多对多已经够用，无需自己创建第三张关系表。但是某些情况可能更复杂一点，比如如果你想保存某个人加入某个分组的时间呢？想保存进组的原因呢？</p>
<p>Django提供了一个<code>through</code>参数，用于指定中间模型，你可以将类似进组时间，邀请原因等其他字段放在这个中间模型内。例子如下：</p>
<pre><code class="hljs python"><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><span class="hljs-params">(models.Model)</span>:</span>
    name = models.CharField(max_length=<span class="hljs-number">128</span>)
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span><span class="hljs-params">(self)</span>:</span> 
        <span class="hljs-keyword">return</span> self.name

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Group</span><span class="hljs-params">(models.Model)</span>:</span>
    name = models.CharField(max_length=<span class="hljs-number">128</span>)
    members = models.ManyToManyField(Person, 		              through=<span class="hljs-string">'Membership'</span>,
         through_fields=(<span class="hljs-string">'group'</span>,<span class="hljs-string">'person'</span>))
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span><span class="hljs-params">(self)</span>:</span> 
        <span class="hljs-keyword">return</span> self.name

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Membership</span><span class="hljs-params">(models.Model)</span>:</span>
    person = models.ForeignKey(Person, on_delete=models.CASCADE)
 group = models.ForeignKey(Group, on_delete=models.CASCADE)
    date_joined = models.DateField()        <span class="hljs-comment"># 进组时间</span>
 invite_reason = models.CharField(max_length=<span class="hljs-number">64</span>)  <span class="hljs-comment"># 邀请原因</span></code></pre>

<p>在中间表中，我们至少要编写两个外键字段，分别指向关联的两个模型。在本例中就是‘Person’和‘group’。 这里，我们额外增加了‘date_joined’字段，用于保存人员进组的时间，‘invite_reason’字段用于保存邀请进组的原因。</p>
<p> <code>through_fields</code>参数接收一个二元元组(‘field1’, ‘field2’)，field1是指向定义有多对多关系的模型的外键字段的名称，这里是Membership中的‘group’字段（注意大小写），另外一个则是指向目标模型的外键字段的名称，这里是Membership中的‘person’ 。</p>
</li>
</ol>
<p>==总结==：在对模型进行反向引用的时候，外键默认使用<code>字段名+_set</code>，一对一可直接使用字段名，多对多默认使用<code>字段名+_set</code>。默认名字可以通过字段属性<code>releted_name</code>重新指定。</p>
<h2 id="模型对象操作"><a href="#模型对象操作" class="headerlink" title="模型对象操作"></a>模型对象操作</h2><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><pre><code class="hljs python"><span class="hljs-keyword">from</span> blog.models <span class="hljs-keyword">import</span> Blog
b = Blog(name=<span class="hljs-string">'Beatles Blog'</span>, tagline=<span class="hljs-string">'All the latest Beatles news.'</span>)
b.save()</code></pre>

<p>当你创建了一个对象以后，如果你没有显示的条用<code>save</code>方法，Django并不会把它插入到数据库中，上面的操作等价于：</p>
<pre><code class="hljs python">b = Blog.objects.create(name=<span class="hljs-string">'Beatles Blog'</span>, tagline=<span class="hljs-string">'All the latest 	            Beatles news.'</span>)</code></pre>

<h3 id="保存对象"><a href="#保存对象" class="headerlink" title="保存对象"></a>保存对象</h3><p><code>save</code>方法还可以用来将对数据的修改保存到数据库中</p>
<pre><code class="hljs python">b.name=<span class="hljs-string">'new name'</span>
b.save()<span class="hljs-comment">#修改之后一定要保存</span></code></pre>

<p>添加修改外键可直接使用上面的保存属性的方法。而对于通过反向引用来添加需使用<code>add</code>方法：</p>
<pre><code class="hljs python">article1=Article(title=<span class="hljs-string">'abc'</span>)
article2=Article(titile=<span class="hljs-string">'def'</span>)
<span class="hljs-comment">#在add之前一定要先保存数据</span>
article1.save()
article2.save()
category.article_set.add(article1,article2)</code></pre>

<p>对于多对多的数据添加，两边对需要使用<code>add</code>方法</p>
<h2 id="QuerySet-API"><a href="#QuerySet-API" class="headerlink" title="QuerySet API"></a>QuerySet API</h2><h3 id="all："><a href="#all：" class="headerlink" title="all："></a><code>all</code>：</h3><p>获取这个模型的<code>QuerySet</code>对象，返回某张表的所有记录</p>
<h3 id="filter-Kwargs-："><a href="#filter-Kwargs-：" class="headerlink" title="filter(**Kwargs)："></a><code>filter(**Kwargs)</code>：</h3><p>返回一个根据指定参数查询出来的QuerySet </p>
<h3 id="exclude-kwargs-："><a href="#exclude-kwargs-：" class="headerlink" title="exclude(**kwargs)："></a><code>exclude(**kwargs)</code>：</h3><p>返回除了根据指定参数查询出来结果的QuerySet </p>
<h3 id="annotate："><a href="#annotate：" class="headerlink" title="annotate："></a><code>annotate</code>：</h3><p>给<code>QuerySet</code>中的每个对象都添加一个使用查询表达式（聚合函数、F表达式、Q表达式、Func表达式等）的新字段。示例代码如下：</p>
<pre><code class="hljs python">articles = Article.objects.annotate(author_name=F(<span class="hljs-string">"author__name"</span>))</code></pre>

<h3 id="aggregate："><a href="#aggregate：" class="headerlink" title="aggregate："></a><code>aggregate</code>：</h3><p>使用聚合函数。 </p>
<h3 id="order-by："><a href="#order-by：" class="headerlink" title="order_by："></a><code>order_by</code>：</h3><p>指定将查询的结果根据某个字段进行排序。如果要倒叙排序，那么可以在这个字段的前面加一个负号。示例代码如下：</p>
<pre><code class="hljs python"><span class="hljs-comment"># 根据创建的时间正序排序</span>
 articles = Article.objects.order_by(<span class="hljs-string">"create_time"</span>)
 <span class="hljs-comment"># 根据创建的时间倒序排序</span>
 articles = Article.objects.order_by(<span class="hljs-string">"-create_time"</span>)
 <span class="hljs-comment"># 根据作者的名字进行排序</span>
 articles = Article.objects.order_by(<span class="hljs-string">"author__name"</span>)
 <span class="hljs-comment"># 首先根据创建的时间进行排序，如果时间相同，则根据作者的名字进行排序</span>
 articles = Article.objects.order_by(<span class="hljs-string">"create_time"</span>,<span class="hljs-string">'author__name'</span>)</code></pre>

<p>一定要注意的一点是，多个<code>order_by</code>，会把前面排序的规则给打乱，而使用后面的排序方式。比如以下代码：</p>
<pre><code class="hljs python">articles = Article.objects.order_by(<span class="hljs-string">"create_time"</span>).order_by(<span class="hljs-string">"author__name"</span>)</code></pre>

<p>他会根据作者的名字进行排序，而不是使用文章的创建时间。</p>
<h3 id="values："><a href="#values：" class="headerlink" title="values："></a><code>values</code>：</h3><p>用来指定在提取数据出来，需要提取哪些字段。默认情况下会把表中所有的字段全部都提取出来，可以使用<code>values</code>来进行指定，并且使用了<code>values</code>方法后，提取出的<code>QuerySet</code>中的数据类型不是模型，而是在<code>values</code>方法中指定的字段和值形成的字典：</p>
<pre><code class="hljs python">articles = Article.objects.values(<span class="hljs-string">"title"</span>,<span class="hljs-string">'content'</span>)
<span class="hljs-keyword">for</span> article <span class="hljs-keyword">in</span> articles:
    print(article)</code></pre>

<p>以上打印出来的<code>article</code>是类似于<code>{&quot;title&quot;:&quot;abc&quot;,&quot;content&quot;:&quot;xxx&quot;}</code>的形式。<br>如果在<code>values</code>中没有传递任何参数，那么将会返回这个模型中所有的属性。</p>
<h3 id="values-list："><a href="#values-list：" class="headerlink" title="values_list："></a><code>values_list</code>：</h3><p>类似于<code>values</code>。只不过返回的<code>QuerySet</code>中，存储的不是字典，而是元组。示例代码如下： </p>
<pre><code class="hljs python">articles = Article.objects.values_list(<span class="hljs-string">"id"</span>,<span class="hljs-string">"title"</span>)
 print(articles)</code></pre>

<p>那么在打印<code>articles</code>后，结果为<code>&lt;QuerySet [(1,&#39;abc&#39;),(2,&#39;xxx&#39;),...]&gt;</code>等。如果在<code>values_list</code>中只有一个字段。那么你可以传递<code>flat=True</code>来将结果扁平化。示例代码如下：</p>
<pre><code class="hljs python">articles1 = Article.objects.values_list(<span class="hljs-string">"title"</span>)
&gt;&gt; &lt;QuerySet [(<span class="hljs-string">"abc"</span>,),(<span class="hljs-string">"xxx"</span>,),...]&gt;
articles2 = Article.objects.values_list(<span class="hljs-string">"title"</span>,flat=<span class="hljs-literal">True</span>)
&gt;&gt; &lt;QuerySet [<span class="hljs-string">"abc"</span>,<span class="hljs-string">'xxx'</span>,...]&gt;</code></pre>

<h3 id="defer："><a href="#defer：" class="headerlink" title="defer："></a><code>defer</code>：</h3><p>在一些表中，可能存在很多的字段，但是一些字段的数据量可能是比较庞大的，而此时你又不需要，比如我们在获取文章列表的时候，文章的内容我们是不需要的，因此这时候我们就可以使用<code>defer</code>来过滤掉一些字段。这个字段跟<code>values</code>有点类似，只不过<code>defer</code>返回的不是字典，而是模型。示例代码如下：</p>
<pre><code class="hljs python">articles = list(Article.objects.defer(<span class="hljs-string">"title"</span>))
<span class="hljs-keyword">for</span> sql <span class="hljs-keyword">in</span> connection.queries:
    print(<span class="hljs-string">'='</span>*<span class="hljs-number">30</span>)
    print(sql)</code></pre>

<p>在看以上代码的<code>sql</code>语句，你就可以看到，查找文章的字段，除了<code>title</code>，其他字段都查找出来了。当然，你也可以使用<code>article.title</code>来获取这个文章的标题，但是会重新执行一个查询的语句。示例代码如下：</p>
<pre><code class="hljs python">articles = list(Article.objects.defer(<span class="hljs-string">"title"</span>))
<span class="hljs-keyword">for</span> article <span class="hljs-keyword">in</span> articles:
    <span class="hljs-comment"># 因为在上面提取的时候过滤了title</span>
    <span class="hljs-comment"># 这个地方重新获取title，将重新向数据库中进行一次查找操作</span>
    print(article.title)
<span class="hljs-keyword">for</span> sql <span class="hljs-keyword">in</span> connection.queries:
    print(<span class="hljs-string">'='</span>*<span class="hljs-number">30</span>)
    print(sql)</code></pre>

<p><code>defer</code>虽然能过滤字段，但是有些字段是不能过滤的，比如<code>id</code>，即使你过滤了，也会提取出来。</p>
<h3 id="only："><a href="#only：" class="headerlink" title="only："></a><code>only</code>：</h3><p>跟<code>defer</code>类似，只不过<code>defer</code>是过滤掉指定的字段，而<code>only</code>是只提取指定的字段。 </p>
<h3 id="select-related："><a href="#select-related：" class="headerlink" title="select_related："></a><code>select_related</code>：</h3><p>在提取某个模型的数据的同时，也提前将相关联的数据提取出来。比如提取文章数据，可以使用<code>select_related</code>将<code>author</code>信息提取出来，以后再次使用<code>article.author</code>的时候就不需要再次去访问数据库了。可以减少数据库查询的次数。示例代码如下：</p>
<pre><code class="hljs python">article = Article.objects.get(pk=<span class="hljs-number">1</span>)
&gt;&gt; article.author <span class="hljs-comment"># 重新执行一次查询语句</span>
article = Article.objects.select_related(<span class="hljs-string">"author"</span>).get(pk=<span class="hljs-number">2</span>)
&gt;&gt; article.author <span class="hljs-comment"># 不需要重新执行查询语句了</span></code></pre>

<p><code>selected_related</code>只能用在<code>一对多</code>或者<code>一对一</code>中，不能用在<code>多对多</code>或者<code>多对一</code>中。比如可以提前获取文章的作者，但是不能通过作者获取这个作者的文章，或者是通过某篇文章获取这个文章所有的标签。</p>
<h3 id="prefetch-related："><a href="#prefetch-related：" class="headerlink" title="prefetch_related："></a><code>prefetch_related</code>：</h3><p>这个方法和<code>select_related</code>非常的类似，就是在访问多个表中的数据的时候，减少查询的次数。这个方法是为了解决<code>多对一</code>和<code>多对多</code>的关系的查询问题。比如要获取标题中带有<code>hello</code>字符串的文章以及他的所有标签，示例代码如下：</p>
<pre><code class="hljs python"><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> connection
articles = Article.objects.prefetch_related(<span class="hljs-string">"tag_set"</span>).filter(title__contains=<span class="hljs-string">'hello'</span>)
print(articles.query) <span class="hljs-comment"># 通过这条命令查看在底层的SQL语句</span>
<span class="hljs-keyword">for</span> article <span class="hljs-keyword">in</span> articles:
    print(<span class="hljs-string">"title:"</span>,article.title)
    print(article.tag_set.all())

<span class="hljs-comment"># 通过以下代码可以看出以上代码执行的sql语句</span>
<span class="hljs-keyword">for</span> sql <span class="hljs-keyword">in</span> connection.queries:
    print(sql)</code></pre>

<p>但是如果在使用<code>article.tag_set</code>的时候，如果又创建了一个新的<code>QuerySet</code>那么会把之前的<code>SQL</code>优化给破坏掉。比如以下代码：</p>
<pre><code class="hljs python">tags = Tag.obejcts.prefetch_related(<span class="hljs-string">"articles"</span>)
<span class="hljs-keyword">for</span> tag <span class="hljs-keyword">in</span> tags:
    articles = tag.articles.filter(title__contains=<span class="hljs-string">'hello'</span>) <span class="hljs-comment">#因为filter方法会重新生成一个QuerySet，因此会破坏掉之前的sql优化</span>

<span class="hljs-comment"># 通过以下代码，我们可以看到在使用了filter的，他的sql查询会更多，而没有使用filter的，只有两次sql查询</span>
<span class="hljs-keyword">for</span> sql <span class="hljs-keyword">in</span> connection.queries:
    print(sql)</code></pre>

<p>那如果确实是想要在查询的时候指定过滤条件该如何做呢，这时候我们可以使用<code>django.db.models.Prefetch</code>来实现，<code>Prefetch</code>这个可以提前定义好<code>queryset</code>。示例代码如下：</p>
<pre><code class="hljs python">tags = Tag.objects.prefetch_related(Prefetch(<span class="hljs-string">"articles"</span>,queryset=Article.objects.filter(title__contains=<span class="hljs-string">'hello'</span>))).all()
<span class="hljs-keyword">for</span> tag <span class="hljs-keyword">in</span> tags:
    articles = tag.articles.all()
    <span class="hljs-keyword">for</span> article <span class="hljs-keyword">in</span> articles:
        print(article)

<span class="hljs-keyword">for</span> sql <span class="hljs-keyword">in</span> connection.queries:
    print(<span class="hljs-string">'='</span>*<span class="hljs-number">30</span>)
    print(sql)</code></pre>

<p>因为使用了<code>Prefetch</code>，即使在查询文章的时候使用了<code>filter</code>，也只会发生两次查询操作。</p>
<h3 id="get："><a href="#get：" class="headerlink" title="get："></a><code>get</code>：</h3><p>获取满足条件的数据。这个函数只能返回一条数据，并且如果给的条件有多条数据，那么这个方法会抛出<code>MultipleObjectsReturned</code>错误，如果给的条件没有任何数据，那么就会抛出<code>DoesNotExit</code>错误。所以这个方法在获取数据的只能，只能有且只有一条。 </p>
<h3 id="bulk-create："><a href="#bulk-create：" class="headerlink" title="bulk_create："></a><code>bulk_create</code>：</h3><p>一次性创建多个数据。示例代码如下：</p>
<pre><code class="hljs python">Tag.objects.bulk_create([
    Tag(name=<span class="hljs-string">'111'</span>),
    Tag(name=<span class="hljs-string">'222'</span>),
])</code></pre>

<h3 id="count："><a href="#count：" class="headerlink" title="count："></a><code>count</code>：</h3><p>获取提取的数据的个数。如果想要知道总共有多少条数据，那么建议使用<code>count</code>，而不是使用<code>len(articles)</code>这种。因为<code>count</code>在底层是使用<code>select count(*)</code>来实现的，这种方式比使用<code>len</code>函数更加的高效。 返回int类型数据。</p>
<h3 id="first和last："><a href="#first和last：" class="headerlink" title="first和last："></a><code>first</code>和<code>last</code>：</h3><p>返回<code>QuerySet</code>中的第一条和最后一条数据。 </p>
<h3 id="exists："><a href="#exists：" class="headerlink" title="exists："></a><code>exists</code>：</h3><p>判断某个条件的数据是否存在。如果要判断某个条件的元素是否存在，那么建议使用<code>exists</code>，这比使用<code>count</code>或者直接判断<code>QuerySet</code>更有效得多。示例代码如下：</p>
<pre><code class="hljs python"><span class="hljs-keyword">if</span> Article.objects.filter(title__contains=<span class="hljs-string">'hello'</span>).exists():
    print(<span class="hljs-literal">True</span>)
比使用count更高效：
<span class="hljs-keyword">if</span> Article.objects.filter(title__contains=<span class="hljs-string">'hello'</span>).count() &gt; <span class="hljs-number">0</span>:
    print(<span class="hljs-literal">True</span>)
也比直接判断QuerySet更高效：
<span class="hljs-keyword">if</span> Article.objects.filter(title__contains=<span class="hljs-string">'hello'</span>):
    print(<span class="hljs-literal">True</span>)</code></pre>

<h3 id="distinct："><a href="#distinct：" class="headerlink" title="distinct："></a><code>distinct</code>：</h3><p>去除掉那些重复的数据。这个方法如果底层数据库用的是<code>MySQL</code>，那么不能传递任何的参数。比如想要提取所有销售的价格超过80元的图书，并且删掉那些重复的，那么可以使用<code>distinct</code>来帮我们实现，示例代码如下：</p>
<pre><code class="hljs python">books = Book.objects.filter(bookorder__price__gte=<span class="hljs-number">80</span>).distinct()</code></pre>

<p>需要注意的是，如果在<code>distinct</code>之前使用了<code>order_by</code>，那么因为<code>order_by</code>会提取<code>order_by</code>中指定的字段，因此再使用<code>distinct</code>就会根据多个字段来进行唯一化，所以就不会把那些重复的数据删掉。示例代码如下：</p>
<pre><code class="hljs python">orders = BookOrder.objects.order_by(<span class="hljs-string">"create_time"</span>).values(<span class="hljs-string">"book_id"</span>).distinct()</code></pre>

<p>那么以上代码因为使用了<code>order_by</code>，即使使用了<code>distinct</code>，也会把重复的<code>book_id</code>提取出来。</p>
<h3 id="update："><a href="#update：" class="headerlink" title="update："></a><code>update</code>：</h3><p>执行更新操作，在<code>SQL</code>底层走的也是<code>update</code>命令。比如要将所有<code>category</code>为空的<code>article</code>的<code>article</code>字段都更新为默认的分类。示例代码如下：</p>
<pre><code class="hljs python">Article.objects.filter(category__isnull=<span class="hljs-literal">True</span>).update(category_id=<span class="hljs-number">3</span>)</code></pre>

<p>注意这个方法走的是更新的逻辑。所以更新完成后保存到数据库中不会执行<code>save</code>方法，因此不会更新<code>auto_now</code>设置的字段。</p>
<h3 id="delete："><a href="#delete：" class="headerlink" title="delete："></a><code>delete</code>：</h3><p>删除所有满足条件的数据。删除数据的时候，要注意<code>on_delete</code>指定的处理方式。 该方法将返回被删除对象的总数量和一个字典，字典包含了每种被删除对象的类型和该类型的数量。如下所示：</p>
<pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>e.delete()
(<span class="hljs-number">1</span>, &#123;<span class="hljs-string">'weblog.Entry'</span>: <span class="hljs-number">1</span>&#125;)</code></pre>

<p>也可以批量删除。每个QuerySet都有一个delete()方法，它能删除该QuepythonrySet的所有成员。例如：</p>
<pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>Entry.objects.filter(pub_date__year=<span class="hljs-number">2005</span>).delete()
(<span class="hljs-number">5</span>, &#123;<span class="hljs-string">'webapp.Entry'</span>: <span class="hljs-number">5</span>&#125;)</code></pre>

<h3 id="update"><a href="#update" class="headerlink" title="update:"></a><code>update</code>:</h3><p>使用<code>update()</code>方法可以批量为QuerySet中所有的对象进行更新操作。</p>
<pre><code class="hljs python"><span class="hljs-comment"># 更新所有2007年发布的entry的headline</span>
Entry.objects.filter(pub_date__year=<span class="hljs-number">2007</span>).update(headline=<span class="hljs-string">'Everything is the same'</span>)</code></pre>

<p>只可以对普通字段和ForeignKey字段使用这个方法。若要更新一个普通字段，只需提供一个新的常数值。若要更新ForeignKey字段，需设置新值为你想指向的新模型实例。例如：</p>
<pre><code class="hljs python">b = Blog.objects.get(pk=<span class="hljs-number">1</span>)
<span class="hljs-comment"># 修改所有的Entry，让他们都属于b</span>
Entry.objects.all().update(blog=b)</code></pre>

<p>update方法会被立刻执行，并返回操作匹配到的行的数目（有可能不等于要更新的行的数量，因为有些行可能已经有这个新值了）。唯一的约束是：只能访问一张数据库表。你可以根据关系字段进行过滤，但你只能更新模型主表的字段。例如：</p>
<pre><code class="hljs python">b = Blog.objects.get(pk=<span class="hljs-number">1</span>)
<span class="hljs-comment"># Update all the headlines belonging to this Blog.</span>
 Entry.objects.select_related().filter(blog=b).update(headline=<span class="hljs-string">'Everything is the same'</span>)</code></pre>

<p>要注意的是update()方法会直接转换成一个SQL语句，并立刻批量执行。它不会运行模型的save()方法，或者产生<code>pre_save</code>或<code>post_save</code>信号（调用<code>save()</code>方法产生）或者服从<code>auto_now</code>字段选项。如果你想保存QuerySet中的每个条目并确保每个实例的save()方法都被调用，你不需要使用任何特殊的函数来处理。只需要迭代它们并调用save()方法：</p>
<pre><code class="hljs python"><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> my_queryset:
    item.save()</code></pre>

<p>update方法可以配合F表达式。这对于批量更新同一模型中某个字段特别有用。例如增加Blog中每个Entry的pingback个数：</p>
<pre><code class="hljs python">Entry.objects.all().update(n_pingbacks=F(<span class="hljs-string">'n_pingbacks'</span>) + <span class="hljs-number">1</span>)</code></pre>

<p>然而，与filter和exclude子句中的F()对象不同，在update中你不可以使用F()对象进行跨表操作，你只可以引用正在更新的模型的字段。如果你尝试使用F()对象引入另外一张表的字段，将抛出FieldError异常：</p>
<pre><code class="hljs python"><span class="hljs-comment"># THIS WILL RAISE A FieldError</span>
Entry.objects.update(headline=F(<span class="hljs-string">'blog__name'</span>))</code></pre>

<p>==update==:不能跨表更新</p>
<h3 id="切片操作："><a href="#切片操作：" class="headerlink" title="切片操作："></a>切片操作：</h3><p>有时候我们查找数据，有可能只需要其中的一部分。那么这时候可以使用切片操作来帮我们完成。<code>QuerySet</code>使用切片操作就跟列表使用切片操作是一样的。示例代码如下：</p>
<pre><code class="hljs python">books = Book.objects.all()[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>]
<span class="hljs-keyword">for</span> book <span class="hljs-keyword">in</span> books:
    print(book)</code></pre>

<p>切片操作并不是把所有数据从数据库中提取出来再做切片操作。而是在数据库层面使用<code>LIMIE</code>和<code>OFFSET</code>来帮我们完成。所以如果只需要取其中一部分的数据的时候，建议使用切片操作。</p>
<h2 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h2><p>查询一般就是使用<code>filter</code>、<code>exclude</code>以及<code>get</code>三个方法来实现。我们可以在调用这些方法的时候传递不同的参数来实现查询需求。在<code>ORM</code>层面，这些查询条件都是使用<code>field</code>+<code>__</code>+<code>condition</code>的方式来使用的。 </p>
<h3 id="exact："><a href="#exact：" class="headerlink" title="exact："></a><code>exact</code>：</h3><p>使用精确的<code>=</code>进行查找，如果提供的是一个<code>None</code>，那么在<code>SQL</code>层面就是被解释为<code>NULL</code>。 </p>
<pre><code class="hljs python">article = Article.objects.get(id__exact=<span class="hljs-number">14</span>)
article = Article.objects.get(id__exact=<span class="hljs-literal">None</span>)</code></pre>

<h3 id="iexact："><a href="#iexact：" class="headerlink" title="iexact："></a><code>iexact</code>：</h3><p>在windows操作系统上。Mysql的排序规则(collation)无论是什么都是大小写不敏感的。在Linux操作系统上，Mysql的排序规则(collation)是utf8_bin那么就是大小写敏感的，iexact和exact可以认为没有区别</p>
<h3 id="contains："><a href="#contains：" class="headerlink" title="contains："></a><code>contains</code>：</h3><p>大小写敏感，判断某个字段是否包含了某个数据。示例代码如下：</p>
<pre><code class="hljs python">articles = Article.objects.filter(title__contains=<span class="hljs-string">'hello'</span>)</code></pre>

<p>在翻译成<code>SQL</code>语句为如下：</p>
<pre><code class="hljs sql"><span class="hljs-keyword">select</span> ... <span class="hljs-keyword">where</span> title <span class="hljs-keyword">like</span> <span class="hljs-built_in">binary</span> <span class="hljs-string">'%hello%'</span>;</code></pre>

<p>要注意的是，在使用<code>contains</code>的时候，翻译成的<code>sql</code>语句左右两边是有百分号的，意味着使用的是模糊查询。而<code>exact</code>翻译成<code>sql</code>语句左右两边是没有百分号的，意味着使用的是精确的查询。</p>
<h3 id="icontains："><a href="#icontains：" class="headerlink" title="icontains："></a><code>icontains</code>：</h3><p><code>contains</code>的大小写不敏感版本</p>
<h3 id="in："><a href="#in：" class="headerlink" title="in："></a><code>in</code>：</h3><p>可以直接指定某个字段的是否在某个集合中。示例代码如下：</p>
<pre><code class="hljs python">articles = Article.objects.filter(id__in=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])</code></pre>

<p>也可以通过其他的表的字段来判断是否在某个集合中。示例代码如下：</p>
<pre><code class="hljs python">categories = Category.objects.filter(article__id__in=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])</code></pre>

<p>如果要判断相关联的表的字段，那么也是通过<code>__</code>来连接。并且在做关联查询的时候，不需要写<code>models_set</code>，直接使用<code>模型的名字的小写化</code>就可以了。比如通过分类去查找相应的文章，那么通过<code>article__id__in</code>就可以了，而不是写成<code>article_set__id__in</code>的形式。当然如果你不想使用默认的形式，可以在外键定义的时候传递<code>related_query_name</code>来指定反向查询的名字。示例代码如下：</p>
<pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Category</span><span class="hljs-params">(models.Model)</span>:</span>
    name = models.CharField(max_length=<span class="hljs-number">100</span>)

    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>:</span>
        db_table = <span class="hljs-string">'category'</span></code></pre>


  <pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Article</span><span class="hljs-params">(models.Model)</span>:</span>
    title = models.CharField(max_length=<span class="hljs-number">200</span>)
    content = models.TextField()
    cateogry = models.ForeignKey(<span class="hljs-string">"Category"</span>,on_delete=models.CASCADE,null=<span class="hljs-literal">True</span>,related_query_name=<span class="hljs-string">'articles'</span>)

    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>:</span>
        db_table = <span class="hljs-string">'article'</span>
        
        
  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Article</span><span class="hljs-params">(models.Model)</span>:</span>
        title = models.CharField(max_length=<span class="hljs-number">200</span>)
        content = models.TextField()
        cateogry = models.ForeignKey(<span class="hljs-string">"Category"</span>,on_delete=models.CASCADE,null=<span class="hljs-literal">True</span>,related_query_name=<span class="hljs-string">'articles'</span>)

        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>:</span>
            db_table = <span class="hljs-string">'article'</span></code></pre>

<p>  因为在<code>cateogry</code>的<code>ForeignKey</code>中指定了<code>related_query_name</code>为<code>articles</code>，因此你不能再使用<code>article</code>来进行反向查询了。这时候就需要通过<code>articles__id__in</code>来进行反向查询。</p>
<p>  反向查询是将模型名字小写化。比如<code>article_in</code>。可以通过<code>related_query_name</code>来指定自己的方式</p>
<p>  反向应用是将模型名字小写化，然后再加上<code>_set</code>，比如<code>article_set</code>，可以通过<code>related_name</code>来指定自己的方式</p>
<p>  并且，如果在做反向查询的时候，如果查询的字段就是模型的主键，那么可以省略掉这个字段，直接写成<code>article__in</code>就可以了，不需要这个<code>id</code>了。</p>
<p>  <code>in</code>不仅仅可以指定列表/元组，还可以为<code>QuerySet</code>。比如要查询“文章标题中包含有hello的所有分类”，那么可以通过以下代码来实现：</p>
   <pre><code class="hljs python">articles = Article.objects.filter(title__icontains=<span class="hljs-string">'hello'</span>)
categories = Category.objects.filter(articles__in=articles)
<span class="hljs-keyword">for</span> cateogry <span class="hljs-keyword">in</span> categories:
    print(cateogry)</code></pre>

<h3 id="gt-gte-lt-lte"><a href="#gt-gte-lt-lte" class="headerlink" title="gt    gte    lt    lte"></a><code>gt</code>    <code>gte</code>    <code>lt</code>    <code>lte</code></h3><p>大于，大于等于，小于，小于等于</p>
<pre><code class="hljs python">articles = Article.objects.filter(id__lte=<span class="hljs-number">3</span>)</code></pre>

<h3 id="startswith："><a href="#startswith：" class="headerlink" title="startswith："></a><code>startswith</code>：</h3><p>判断某个字段的值是否是以某个值开始的。大小写敏感。示例代码如下：</p>
<pre><code class="hljs python">articles = Article.objects.filter(title__startswith=<span class="hljs-string">'hello'</span>)</code></pre>

<p>以上代码的意思是提取所有标题以<code>hello</code>字符串开头的文章。<br>将翻译成以下<code>SQL</code>语句：</p>
<pre><code class="hljs sql"><span class="hljs-keyword">select</span> ... <span class="hljs-keyword">where</span> title <span class="hljs-keyword">like</span> <span class="hljs-string">'hello%'</span></code></pre>

<h3 id="istartswith："><a href="#istartswith：" class="headerlink" title="istartswith："></a><code>istartswith</code>：</h3><p>类似于<code>startswith</code>，但是大小写是不敏感的。</p>
<h3 id="endswith："><a href="#endswith：" class="headerlink" title="endswith："></a><code>endswith</code>：</h3><p>判断某个字段的值是否以某个值结束。大小写敏感。示例代码如下：</p>
<pre><code class="hljs python">articles = Article.objects.filter(title__endswith=<span class="hljs-string">'world'</span>)</code></pre>

<p>以上代码的意思是提取所有标题以<code>world</code>结尾的文章。<br>将翻译成以下<code>SQL</code>语句：</p>
<pre><code class="hljs sql"><span class="hljs-keyword">select</span> ... <span class="hljs-keyword">where</span> title <span class="hljs-keyword">like</span> <span class="hljs-string">'%world'</span>;</code></pre>

<h3 id="iendswith："><a href="#iendswith：" class="headerlink" title="iendswith："></a><code>iendswith</code>：</h3><p>类似于<code>endswith</code>，只不过大小写不敏感。</p>
<h3 id="range："><a href="#range：" class="headerlink" title="range："></a><code>range</code>：</h3><p>可以指定一个时间段。并且时间应该标记为<code>aware</code>时间，不然django会报警告。示例代码如下：</p>
<pre><code class="hljs python">start_time = make_aware(datetime(year=<span class="hljs-number">2018</span>,month=<span class="hljs-number">4</span>,day=<span class="hljs-number">4</span>,hour=<span class="hljs-number">17</span>,minute=<span class="hljs-number">0</span>,second=<span class="hljs-number">0</span>))
end_time = make_aware(datetime(year=<span class="hljs-number">2018</span>,month=<span class="hljs-number">4</span>,day=<span class="hljs-number">4</span>,hour=<span class="hljs-number">18</span>,minute=<span class="hljs-number">0</span>,second=<span class="hljs-number">0</span>))
articles = Article.objects.filter(create_time__range=(start_time,end_time))</code></pre>

<p>==注意==：虽然数据库中保存的时间是UTC时间但是操作时可以直接采用设置时区的时间，django会自动进行转换</p>
<p>可以使用django内置的<code>make_aware</code>将<code>navie</code>时间转化为<code>aware</code>时间</p>
<h3 id="date："><a href="#date：" class="headerlink" title="date："></a><code>date</code>：</h3><p>用年月日来进行过滤。如果想要使用这个过滤条件，那么前提必须要在<code>MySQL</code>中添加好那些时区文件。如何添加呢？参考教案。示例代码如下：</p>
<pre><code class="hljs python">articles = Article.objects.filter(create_time__date=datetime(year=<span class="hljs-number">2018</span>,month=<span class="hljs-number">4</span>,day=<span class="hljs-number">4</span>))</code></pre>

<h3 id="year-month-day："><a href="#year-month-day：" class="headerlink" title="year   month   day："></a><code>year</code>   <code>month</code>   <code>day</code>：</h3><p>表示根据年/月/日进行查找。示例代码如下：</p>
<pre><code class="hljs python">articles = Article.objects.filter(create_time__year__gte=<span class="hljs-number">2018</span>)</code></pre>

<p>week_day：根据星期来进行查找。1表示星期天，7表示星期六，2-6代表的是星期一到星期五。比如要查找星期三的所有文章，那么可以通过以下代码来实现：</p>
<pre><code class="hljs python">articles = Article.objects.filter(create_time__week_day=<span class="hljs-number">4</span>)</code></pre>

<h3 id="time："><a href="#time：" class="headerlink" title="time："></a><code>time</code>：</h3><p>根据分时秒来进行查找。如果要具体到秒，一般比较难匹配到，可以使用区间的方式来进行查找。区间使用<code>range</code>条件。比如想要获取17时/10分/27-28秒之间的文章，那么可以通过以下代码来实现：</p>
<pre><code class="hljs python">start_time = time(hour=<span class="hljs-number">17</span>,minute=<span class="hljs-number">10</span>,second=<span class="hljs-number">27</span>)
end_time = time(hour=<span class="hljs-number">17</span>,minute=<span class="hljs-number">10</span>,second=<span class="hljs-number">28</span>)
articles = Article.objects.filter(create_time__time__range=(start_time,end_time))</code></pre>

<h3 id="isnull："><a href="#isnull：" class="headerlink" title="isnull："></a><code>isnull</code>：</h3><p>根据值是否为空进行查找。示例代码如下：</p>
<pre><code class="hljs python">articles = Article.objects.filter(pub_date__isnull=<span class="hljs-literal">False</span>)</code></pre>

<p>以上的代码的意思是获取所有发布日期不为空的文章。<br>将来翻译成<code>SQL</code>语句如下：</p>
<pre><code class="hljs sql"><span class="hljs-keyword">select</span> ... <span class="hljs-keyword">where</span> pub_date <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span>;</code></pre>

<h3 id="regex-iregex："><a href="#regex-iregex：" class="headerlink" title="regex   iregex："></a><code>regex</code>   <code>iregex</code>：</h3><p>大小写敏感和大小写不敏感的正则表达式。示例代码如下：</p>
<pre><code class="hljs python">articles = Article.objects.filter(title__regex=<span class="hljs-string">r'^hello'</span>)</code></pre>

<p>以上代码的意思是提取所有标题以<code>hello</code>字符串开头的文章。<br>将翻译成以下的<code>SQL</code>语句：</p>
<pre><code class="hljs sql"><span class="hljs-keyword">select</span> ... <span class="hljs-keyword">where</span> title regexp <span class="hljs-built_in">binary</span> <span class="hljs-string">'^hello'</span>;</code></pre>

<p><code>iregex</code>是大小写不敏感的。</p>
<h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><ol>
<li><p>所有的聚合函数都是放在<code>django.db.models</code>下面。</p>
</li>
<li><p>聚合函数不能够单独的执行，需要放在一些可以执行聚合函数的方法下面中去执行。比如<code>aggregate</code>。示例代码如下：</p>
<pre><code class="hljs python">result = Book.objects.aggregate(Avg(<span class="hljs-string">"price"</span>))</code></pre>
</li>
<li><p>聚合函数执行完成后，给这个聚合函数的值取个名字。取名字的规则，默认是<code>filed+__+聚合函数名字</code>形成的。比如以上代码形成的名字叫做<code>price__avg</code>。如果不想使用默认的名字，那么可以在使用聚合函数的时候传递关键字参数进去，参数的名字就是聚合函数执行完成的名字。实示例代码如下：</p>
<pre><code class="hljs python">result = Book.objects.aggregate(avg=Avg(<span class="hljs-string">"price"</span>))</code></pre>

<p>以上传递了关键字参数<code>avg=Avg(&quot;price&quot;)</code>，那么以后<code>Avg</code>聚合函数执行完成的名字就叫做<code>avg</code>。</p>
</li>
</ol>
<h3 id="aggregate：-1"><a href="#aggregate：-1" class="headerlink" title="aggregate："></a><code>aggregate</code>：</h3><p>这个方法不会返回一个<code>QuerySet</code>对象，而是返回一个字典。这个字典中的key就是聚合函数的名字，值就是聚合函数执行后的结果。</p>
<ol start="5">
<li><code>aggregate</code>和<code>annotate</code>的相同和不同：</li>
</ol>
<ul>
<li>相同：这两个方法都可以执行聚合函数。<ul>
<li>不同：<ul>
<li><code>aggregate</code>返回的是一个字典，在这个字典中存储的是这个聚合函数执行的结果。而<code>annotate</code>返回的是一个<code>QuerySet</code>对象，并且会在查找的模型上添加一个聚合函数的属性。</li>
<li><code>aggregate</code>不会做分组，而<code>annotate</code>会使用<code>group by</code>子句进行分组，只有调用了<code>group by</code>子句，才能对每一条数据求聚合函数的值。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Count："><a href="#Count：" class="headerlink" title="Count："></a><code>Count</code>：</h3><p>用来求某个数据的个数。比如要求所有图书的数量，那么可以使用以下代码：</p>
<pre><code class="hljs python">result = Book.objects.aggregate(book_nums=Count(<span class="hljs-string">"id"</span>))</code></pre>

<p>并且<code>Count</code>可以传递<code>distinct=True</code>参数，用来剔除那些重复的值，只保留一个。比如要获取作者表中，不同邮箱的个数，那么这时候可以使用<code>distinct=True</code>。示例代码如下：</p>
<pre><code class="hljs python">result = Author.objects.aggregate(email_nums=Count(<span class="hljs-string">'email'</span>,distinct=<span class="hljs-literal">True</span>))</code></pre>

<h3 id="Max和Min："><a href="#Max和Min：" class="headerlink" title="Max和Min："></a><code>Max</code>和<code>Min</code>：</h3><p>求指定字段的最大值和最小值。示例代码如下：</p>
<pre><code class="hljs python">result = Author.objects.aggregate(max=Max(<span class="hljs-string">"age"</span>),min=Min(<span class="hljs-string">"age"</span>))</code></pre>

<h3 id="Sum："><a href="#Sum：" class="headerlink" title="Sum："></a><code>Sum</code>：</h3><p>求某个字段值的总和。示例代码如下：</p>
<pre><code class="hljs python">result = BookOrder.objects.aggregate(total=Sum(<span class="hljs-string">'price'</span>))</code></pre>

<p><code>aggregate</code>和<code>annotate</code>方法可以在任何的<code>QuerySet</code>对象上调用。因此只要是返回了<code>QuerySet</code>对象，那么就可以进行链式调用。比如要获取2018年度的销售总额，那么可以先过滤年份，再求聚合函数。示例代码如下：</p>
<pre><code class="hljs python">BookOrder.objects.filter(create_time__year=<span class="hljs-number">2018</span>).aggregate(total=Sum(<span class="hljs-string">'price'</span>))</code></pre>

<h3 id="F表达式和Q表达式"><a href="#F表达式和Q表达式" class="headerlink" title="F表达式和Q表达式"></a>F表达式和Q表达式</h3><h3 id="Q表达式："><a href="#Q表达式：" class="headerlink" title="Q表达式："></a>Q表达式：</h3><p>使用<code>Q</code>表达式包裹查询条件，可以在条件之间进行多种操作。与/或非等，从而实现一些复杂的查询操作。例子如下：</p>
<p>查找价格大于100，并且评分达到4.85以上的图书：</p>
<pre><code class="hljs python"><span class="hljs-comment"># 不使用Q表达式的</span>
books = Book.objects.filter(price__gte=<span class="hljs-number">100</span>,rating__gte=<span class="hljs-number">4.85</span>)
<span class="hljs-comment"># 使用Q表达式的</span>
books = Book.objects.filter(Q(price__gte=<span class="hljs-number">100</span>)&amp;Q(rating__gte=<span class="hljs-number">4.85</span>))</code></pre>

<ul>
<li><p>查找价格低于100元，或者评分低于4分的图书：</p>
<pre><code class="hljs python">books = Book.objects.filter(Q(price__gte=<span class="hljs-number">100</span>)&amp;Q(rating__gte=<span class="hljs-number">4.85</span>))</code></pre>
</li>
<li><p>获取价格大于100，并且图书名字中不包含”传“字的图书：</p>
<pre><code class="hljs python">books = Book.objects.filter(Q(price__gte=<span class="hljs-number">100</span>)&amp;~Q(name__icontains=<span class="hljs-string">'传'</span>))</code></pre>
</li>
</ul>
<ul>
<li><p>当关键字参数和Q对象组合使用时，Q对象必须放在前面，如下例子：</p>
<pre><code class="hljs routeros">Poll.objects.<span class="hljs-builtin-name">get</span>(
Q(<span class="hljs-attribute">pub_date</span>=date(2005, 5, 2)) | Q(<span class="hljs-attribute">pub_date</span>=date(2005, 5, 6)),<span class="hljs-attribute">question__startswith</span>=<span class="hljs-string">'Who'</span>,)</code></pre>

<p>如果关键字参数放在Q对象的前面，则会报错。</p>
</li>
</ul>
<h3 id="F表达式："><a href="#F表达式：" class="headerlink" title="F表达式："></a>F表达式：</h3><p>到目前为止的例子中，我们都是将模型字段与常量进行比较。但是，如果你想将模型的一个字段与同一个模型的另外一个字段进行比较该怎么办？</p>
<p>使用Django提供的F表达式！</p>
<p>例如，为了查找comments数目多于pingbacks数目的Entry，可以构造一个<code>F()</code>对象来引用pingback数目，并在查询中使用该F()对象：</p>
<pre><code class="hljs python"><span class="hljs-keyword">from</span> django.db.models <span class="hljs-keyword">import</span> F
Entry.objects.filter(n_comments__gt=F(<span class="hljs-string">'n_pingbacks'</span>))</code></pre>

<p>Django支持对F()对象进行加、减、乘、除、取模以及幂运算等算术操作。两个操作数可以是常数和其它F()对象。例如查找comments数目比pingbacks两倍还要多的Entry，我们可以这么写：</p>
<pre><code class="hljs python">Entry.objects.filter(n_comments__gt=F(<span class="hljs-string">'n_pingbacks'</span>) * <span class="hljs-number">2</span>)</code></pre>

<p>为了查询rating比pingback和comment数目总和要小的Entry，我们可以这么写：</p>
<pre><code class="hljs python">Entry.objects.filter(rating__lt=F(<span class="hljs-string">'n_comments'</span>) + F(<span class="hljs-string">'n_pingbacks'</span>))</code></pre>

<p>你还可以在F()中使用双下划线来进行跨表查询。例如，查询author的名字与blog名字相同的Entry：</p>
<pre><code class="hljs python">Entry.objects.filter(authors__name=F(<span class="hljs-string">'blog__name'</span>))</code></pre>

<p>对于date和date/time字段，还可以加或减去一个timedelta对象。下面的例子将返回发布时间超过3天后被修改的所有Entry：</p>
<pre><code class="hljs python"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> timedelta
Entry.objects.filter(mod_date__gt=F(<span class="hljs-string">'pub_date'</span>) + timedelta(days=<span class="hljs-number">3</span>))</code></pre>

<h2 id="ORM模型迁移"><a href="#ORM模型迁移" class="headerlink" title="ORM模型迁移"></a>ORM模型迁移</h2><h3 id="makemigrations："><a href="#makemigrations：" class="headerlink" title="makemigrations："></a><code>makemigrations</code>：</h3><p>将模型生成迁移脚本。模型所在的<code>app</code>，必须放在<code>settings.py</code>中的<code>INSTALLEN_APPS</code>中。这个命令有以下几个常用选项：</p>
<ul>
<li><p>app_label:后面可以跟一个或者多个<code>app</code>，那么就会只针对这几个<code>app</code>生成迁移脚本。如果没有任何的app_label，那么会检查<code>INSTALLED_APPS</code>中所有的<code>app</code>下的模型，如果发生了更改就会生成迁移脚本。</p>
<pre><code class="hljs python">python manage.py makemigrations book</code></pre>
</li>
<li><p>–name：给这个迁移脚本指定一个名字。</p>
<pre><code class="hljs python">python manage.py makemigrations book --name<span class="hljs-string">"remove_content"</span></code></pre>
</li>
<li><p>–empty： 生成一个空的迁移脚本。如果你想写自己的迁移脚本，可以使用这个命令来实现一个空的文件，然后自己再在文件中写迁移脚本。 </p>
</li>
</ul>
<h3 id="migrate："><a href="#migrate：" class="headerlink" title="migrate："></a><code>migrate</code>：</h3><ul>
<li>app_label：同上</li>
<li>–fake： 可以将指定的迁移脚本名字添加到数据库中。但是并不会把迁移脚本转换为SQL语句，修改数据库中的表。 </li>
<li>–fake-initial：将第一次生成的迁移文件版本号记录在数据库中。但并不会真正的执行迁移脚本。 </li>
<li>showmigrations：查看某个app下的迁移文件。如果后面没有app，那么将查看<code>INSTALLED_APPS</code>中所有的迁移文件。 </li>
<li>sqlmigrate：查看某个迁移文件在映射到数据库中的时候，转换的<code>SQL</code>语句。 </li>
</ul>
<h3 id="django模型迁移的步骤："><a href="#django模型迁移的步骤：" class="headerlink" title="django模型迁移的步骤："></a>django模型迁移的步骤：</h3><ol>
<li>迁移判定，将你的项目中的迁移脚本同数据库中的表django_migreations判断是否有新的迁移，django会执行没有的迁移脚本。</li>
</ol>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/blog/tags/%E7%AE%97%E6%B3%95/">算法</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/blog/2020/06/28/leetcode%E9%A2%98%E8%A7%A3/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">leetcode题解</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/blog/2020/06/28/leetcode%E9%A2%98%E8%A7%A3/java/">
                        <span class="hidden-mobile">leetcode题解/java</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


    
  <!-- 备案信息 -->
  <div class="beian">
    <a href="http://beian.miit.gov.cn/" target="_blank"
       rel="nofollow noopener">京ICP证123456号</a>
    
      <a
        href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=12345678"
        rel="nofollow noopener"
        class="beian-police"
        target="_blank"
      >
        <span class="beian-police-sep">&nbsp;|&nbsp;</span>
        
          <img src="/blog/img/police_beian.png" srcset="/blog/img/loading.gif" alt="police-icon" />
        
        <span>京公网安备12345678号</span>
      </a>
     
  </div>


    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/blog/js/debouncer.js" ></script>
<script  src="/blog/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/blog/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/blog/js/clipboard-use.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "leetcode题解&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 140,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
      icon: "❡"
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/blog/js/local-search.js" ></script>
  <script>
    var path = "/blog/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>




















</body>
</html>
